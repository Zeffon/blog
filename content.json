[{"title":"win10批量修改文件名","date":"2020-06-21T13:31:39.000Z","path":"posts/e12a97ac.html","text":"记录在win10系统下批量修改文件名的方法 正文生成rename.xls文件使用win键+R cmd指令打开控制台（别关掉 ~） 123$ chcp 65001 # 先切换为编码，防止后续出现乱码$ cd 需要修改文件的目录$ dir /b&gt;rename.xls # 会在目录生成rename.xls文件 定制rename.xls生成的rename.xls如图所示第一列是固定为ren指令 第二列是原文件名 第三列是新文件名 可以利用替换(Ctrl+h)的方式来实现批量修改文件名如果文件名中出现有空格，需要整个文件名前后加上英文双引号 执行bat批量文件 将上面xls文件(除开第一行)的内容复制 在之前的目录中新建文件ren.txt 在ren.txt文件中进行粘贴 修改ren.txt的扩展名为bat即ren.bat文件在控制台执行1$ .\\ren.bat document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"nginx.conf中server模块location","date":"2020-05-11T08:29:04.000Z","path":"posts/f0100941.html","text":"nginx.conf配置中，http指令块中的server模块的location是主要匹配客户端发送过来url的 正文nginx服务器匹配单个location当我们访问 localhost:88 将会被转到 /home/html 目录下 主页是index.html例如我们访问 localhost:88/img/a.png 会访问到服务器 /home/nginx/img/a.png 123456789server { listen 88; server_name localhost; location / { root /home/nginx; index index.html; }} 多个location如果访问 localhost:88/img 匹配到 img 这样会将 /img 拼接到 /home/demo 的后面，这时候就会访问到服务器/home/demo/img目录下例如我们访问 localhost:88/img/a.png 会访问到服务器 /home/demo/img/a.png 1234567891011121314server { listen 88; server_name localhost; location / { root /home; index index.html; } location /img { root /home/demo; index index.html; }} 采用别名alias，这样可以自定义url上的参数访问 localhost:88/demo/a.png 匹配 demo 会将demo拼接在 /hemo 后面，访问到服务器/home/demo/a.png访问 localhost:88/static/a.png 识别出别名alias 会将 static 替换 /home/demo，也访问到服务器/home/demo/a.png所以localhost:88/demo/a.png 和 localhost:88/static/a.png 两者可以达到同样的效果，也可以同时使用 12345678910111213141516171819server { listen 88; server_name localhost; location / { root /home; index index.html; } location /demo { root /home; index index.html; } location /static { alias /home/demo; index index.html; }} location匹配规则 空格 ：默认匹配，普通匹配location / { root /home;} = ：精确匹配location = /demo/img/a.png { root /home;} ~* ：匹配正则表达式，不区分大小写#符合图片的显示location ~* .(GIF|jpg|png|jpeg) { root /home;} ~ ：匹配正则表达式，区分大小写#GIF必须大写才能匹配到location ~ .(GIF|jpg|png|jpeg) { root /home;} ^~ ：以某个字符路径开头location ^~ /demo/img { root /home;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.zeffon.cn/tags/nginx/"}]},{"title":"nginx.conf配置文件","date":"2020-05-04T02:47:06.000Z","path":"posts/7a42ed0e.html","text":"Nginx的核心配置文件nginx.conf的配置结构和指令语法 前文想要使用好nginx，绕不开其核心配置文件的熟练掌握，以下主要是nginx.conf的配置结构和相关的指令语法 正文main 全局配置main配置影响nginx全局的指令。一般有运行nginx服务器的用户组、允许运行的工作进行数worker process、nginx进程pid存放路径、日志存放路径，配置文件引入等。 设置work进程的用户，指的是linux中的用户，会涉及到nginx操作目录或文件的一些权限，默认是nobody 1user root work工作进程数设置，一般来说CPU有几个，就设置几个，或者设置N-1也可以 1worker_processes 1; 设置nginx进程 pid 1pid logs/nginx.pid nginx日志级别(级别从左到右越来越大)debug -&gt; info -&gt; notice -&gt; warn -&gt; error -&gt; crit -&gt; alert -&gt; emerg nginx日志存放路径设置 1error_log logs/error.log; events 工作模式配置配置影响nginx服务器或与用户的网络连接。有每个工作进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 123456events { # 默认使用epoll（多路复用） use epoll; # 每个work工作进行允许连接的客户端最大连接数 worker_connections 10240;} http 指令块配置http是指令块，针对http网络传输的一些指令配置在http模块中可以嵌套多个server，配置相关代理、设置缓存、自定义日志（日志切割）等绝大多数功能和第三方模块的配置。如外部配置文件引入、日志自定义、是否使用sendfile传输文件、连接超时时间、gzip压缩等。 引入外部配置文件，提高可读性，避免单个文件配置过大 1include /usr/local/nginx/conf/vhosts/*.conf; 自定义日志 参数名 参数意义 $romote_addr 客户端ip $romote_user 远程客户端用户名，一般为”-“ $time_local 时间与时区 $request 请求url与method $status 响应状态码 $body_bytes_send 响应客户端内容字节数 $http_referer 记录用户从哪个链接跳转过来的 $http_user_agent 用户所使用的代理，一般都是浏览器 $http_x_forwarded_for 通过代理服务器来记录客户端的ip sendfile使用高效文件传输，提升传输性能。启用后才能使用tcp_nopush,是指当数据表累计一定大小才发送，提高效率 12sendfile on;tcp_nopush on; keepalive_timeout 设置客户端与服务端请求的超时时间，保证客户端多次请求的时候不会重复建立新的连接，节约资源损耗 1keepalive_timeout 65; gzip启用压缩，html/js/css等静态资源压缩后传输会更快 1gzip on; server 模块配置location 路由规则server可以在http指令块中设置多个虚拟主机 listen 监听端口 server_name localhost、ip、域名 location 请求路由映射、匹配拦截 root 请求位置 index 首页设置 123456789server { listen 8080; server_name localhost; location / { root html; index index.html index.htm; }} upstream 集群 内网服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.zeffon.cn/tags/nginx/"}]},{"title":"Nginx基本认知","date":"2020-04-27T00:39:29.000Z","path":"posts/5d519c47.html","text":"Nginx作为最常见的服务器，我们不但要知道能将项目部署在上面，还要知道其相关原理。 正文Nginx方向代理大多时候我们使用Nginx时，可能都会使用Nginx反向代理的功能。那么什么是反向代理呢？在理解什么是Nginx反向代理时，我们先得知道什么是正向代理。 正向代理正向代理服务器是客户端请求目标服务器之间的一个代理服务器。一般我们发送了一个请求后，它会先经过代理服务器，然后在经过代理服务器转发请求到指定的目标服务器，获得内容后将结果最终响应给客户端。 反向代理反向代理：用户请求目标服务器，由代理服务器决定访问哪个ip目标服务器 联系理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是我们是不知道代理服务器具体访问哪个ip目标服务器的。 Nginx进程模型Nginx作为高性能的服务器，离不开良好进程模型的支持。Nginx有Master主进程和Worker工作进程。对于每个Worker进程来说，它们都是独立的进程，互相之间不会影响。Master进程通过发指令信号的形式通知Worker工作进程 Master进程主要用来管理Worker进程 Master进程接收来自外界的信号 Master进程向各Worker进程发送信号 Master进程监控Worker进程的运行状态 当Worker进程异常退出后，会自动重新启动新的Worker进程。 我们可以在配置文件nginx.conf配置Worker进程的数量worker_processes 2 Nginx请求机制对于Nginx为什么性能这么高，能达到这么高的并发,最主要的是有Worker抢占机制和处理请求的模型是异步非阻塞(多路复用器) 传统服务器-同步阻塞传统服务器中，客户端发起一个请求，如果处理这个请求的工作进程由于处理的时间比较长被阻塞住了，那么它将不会处理后续其它Client的请求。Master进程会fork出新的Worker2进程来处理。很显然这种方式是不好的，如果刚fork的Worker2进程也被阻塞的话，Master又只能fork出现Worker进程。在高并发情况，发生阻塞的话，服务器会开很多进程来处理，这对服务器资源开销是非常大的。这就是同步阻塞的弊端。这在高并发情况下，这无疑是一场灾难。 Nginx服务器-异步非阻塞Nginx服务器，客户端发起一个请求，即便处理这个请求的工作进程1被阻塞住了，是不会影响它处理其它客户端的请求的，这样就不需要fork新的Worker进程来处理其它客户端的请求。这是异步非阻塞的好处。 Nginx Worker抢占机制当一个请求过来时，会有一个accept_mutex 互斥锁。Worker进程会抢占这个锁，抢到后才能处理相对应客户端的请求，假设Worker1抢到这个锁后会建立关系，Worker1就会处理这个请求，将这个请求进行解析、处理、响应，而Worker2和Worker3没抢到则不需操作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.zeffon.cn/tags/nginx/"}]},{"title":"Redis缓存雪崩、穿透","date":"2020-04-20T03:09:24.000Z","path":"posts/aacd080c.html","text":"在使用redis作为缓存层时，有时候不好的程序设计会导致Redis缓存雪崩和穿透问题。 前言正文缓存雪崩雪崩 ：Redis中有大量的key，会设置过期时间。如果过期时间有太多重合的，那么在某个时间点会有大量key失效了或是由于Redis宕机了恰好这时候有很大很大的流量流入进来。那么这个时候所有的请求不会再经过Redis缓存层，而是都会直接打在数据库上，数据库可能会处理不过来导致宕机崩溃。 原本是会经过缓冲层由于缓存失效或者宕机请求直接访问Mysql 预防方案 ： 采用Key永不过期机制 采用key过期时间错开(推荐) 多缓存结合使用 缓存穿透穿透 ： 接受一个id，先从redis查询有没有对应值，没有再从数据中查询，查询结果进行判断，有数据才将其写进redis里。下次再查询就不要查询数据库了，而redis起了一个缓存的作用。但是这种情况只适合id是存在数据库。如果用户传入一个非法、数据库不存在的id，那么一直使用该id请求的话，程序就会一直访问数据库，这样无法缓存了，直接把缓存穿透了。 处理方案 ：不管数据库查询的结果有没有数据，都将其进行缓存。把空的数据(空字符串、空对象、空数组、空列表)缓存起来。（就是针对一个不存在的key去为它设置一个空值，即使后面我们可能会使用这个不存在的key时，set时也会把之前的空值覆盖的） 布隆过滤器 ： 可以迅速地判断一个元素是否在一个集合里，相当一种拦截器，是在redis前面进行拦截。以HashMap的Key-Value的形式可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是存储容量占比高，数据量太多时会占据内存并且有1%误判率的缺点。 区别缓存穿透是单个key的大量请求打在数据库上，缓存雪崩是大量key失效导致大量请求直接打在数据库 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"redis","slug":"redis","permalink":"https://www.zeffon.cn/tags/redis/"}]},{"title":"Jpa返回自定义对象","date":"2020-04-13T00:51:53.000Z","path":"posts/f2ed05e0.html","text":"在使用Jpa作为持久层时，Repository层的返回对象往往是模型继承JpaRepository中的对象，想要直接使用其它对象是不行的。那么我们该怎么处理呢？ 前文在使用Jpa作为持久层时，Repository层的返回对象往往是模型继承JpaRepository中的对象，想要直接使用其它对象是不行的。如果我们连表后数据不能作为一个对象返回，那么在去处理或者再去查询数据库都是不好的。所以我们在连表操作时，通过@Query注解里的new 自定义的对象,将我们需要的字段以参数形式传入自定义对象构造函数中，最后返回对象即可。 还有一种方法：就是将查询的处理以Object对象返回，然后需要转成指定的对象。(不推荐) 正文返回对象 通常Repository层写时，我们只能返回将模型Dormitory的数据返回，并不能返回其它的对象。 1234@Repositorypublic interface DormitoryRepository extends JpaRepository&lt;Dormitory, Long&gt; {} 如果我们连表的话，肯定会想返回自定义的对象。 123456789@Repositorypublic interface DormitoryRepository extends JpaRepository&lt;Dormitory, Long&gt; { /** 获取楼号和房间号 */ @Query(\"SELECT new com.zeffon.yusu.bo.DormitoryAndRoomBO(f.id, f.name, c.id, c.name)\\n\" + \"FROM Dormitory c\\n\" + \"LEFT JOIN Dormitory f ON f.id = c.parentId\\n\" + \"WHERE c.id = :rid\") DormitoryAndRoomBO findDormitoryAndRoom(Long rid);} 对应的自定义对象DormitoryAndRoomBO需要有相对应的构造函数 12345678910111213141516@Getter@Setterpublic class DormitoryAndRoomBO { private Long roomId; private String room; private Long dormitoryId; private String dormitory; // 如果不想写这么麻烦的构造函数，也可以使用@AllArgsConstructor注解，不过参数要注意顺序 public DormitoryAndRoomBO(Long dormitoryId, String dormitory, Long roomId, String room) { this.roomId = roomId; this.room = room; this.dormitoryId = dormitoryId; this.dormitory = dormitory; }} 返回列表如果返回的是列表也很简单，只需要修改repository中对应方法的返回类型即可 123456789@Repositorypublic interface DormitoryRepository extends JpaRepository&lt;Dormitory, Long&gt; { /** 获取楼号和房间号 */ @Query(\"SELECT new com.zeffon.yusu.bo.DormitoryAndRoomBO(f.id, f.name, c.id, c.name)\\n\" + \"FROM Dormitory c\\n\" + \"LEFT JOIN Dormitory f ON f.id = c.parentId\\n\" + \"WHERE c.id = :rid\") List&lt;DormitoryAndRoomBO&gt; findDormitoryAndRoom(Long rid);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"},{"name":"JPA","slug":"JPA","permalink":"https://www.zeffon.cn/tags/JPA/"}]},{"title":"Java注解检验器","date":"2020-04-06T14:19:01.000Z","path":"posts/cb1a6b6.html","text":"平时在写参数校验可能大多会在service层使用if语句的方式来判断，其实我们可以很优雅的使用参数校验–注解检验器 前言平时在写参数校验可能大多会在service层使用if语句的方式来判断，其实我们可以很优雅的使用参数校验–注解检验器。注解验证器是通过注解的方式给一些字段、方法、类加上了注解，不同的注解有着不同的校验，这样能帮助我们更优雅的写出代码来，可读性也是不错。 正文JSR-303JSR-303 提供一个验证标准Validation，我们会常常使用到的： @Min和@Max 最小和最大数限制 @Positive 整数校验 @NotBlank 校验字符串非空，长度大于0 @Email 邮箱校验 @Range 范围校验 @Lenght 长度校验 @NotNull 不为空检验 @Future 必须是将来日期校验… … 简单字段校验JSR-303的注解用在简单字段上，如要求id为整数，最大不可超过10 12345678@RestController@RequestMapping(\"/hello\")public class Hello() { @GetMapping(\"\") public void hello(@Positive @Max(value=10, message=\"不用超过10咯\") Integer id) { System.out.println(id); }} 但是这样是不能开启验证的，我们需要的类上加上注解@Validated才能使注解验证生效。（还可以自定义错误消息） 123456789@RestController@RequestMapping(\"/hello\")@Validated // 这里加上 @Validatedpublic class Hello() { @GetMapping(\"\") public void hello(@Positive @Max(value=10, message=\"不用超过10咯\") Integer id) { System.out.println(id); }} Body校验有时候我们需要校验body里面的参数校验 123456789101112131415161718@RestController@RequestMapping(\"/hello\")@Validatedpublic class Hello { @PostMapping(\"\") public void say(@RequestBody Person person) { System.out.println(person.age); }}@Getter@Setterpubilc class Person { @Lenght(min=2, max=10, message=\"别超出范围\") private String name; private Integer age;} 这时候还是不能校验body里面的参数，原因是校验没有生效。类上的@Validated是给该类下字段开启校验的，而我们要校验的age是在Person类下，那我们需要跑到Person类打上注解吗？并不需要, 只需要在对应传入参数打上就行了 123456789@RestController@RequestMapping(\"/hello\")@Validatedpublic class Hello { @PostMapping(\"\") public void say(@RequestBody @Validated Person person) { // 这里加上 @Validated System.out.println(person.age); }} 级联校验有时候传入的body对象又包含了对象，那这时候又如何校验呢？ 123456789101112131415161718192021222324252627@RestController@RequestMapping(\"/hello\")@Validatedpublic class Hello { @PostMapping(\"\") public void say(@RequestBody Person person) { System.out.println(person.age); }}@Getter@Setterpubilc class Person { @Lenght(min=2, max=10, message=\"别超出范围\") private String name; private Integer age; private Car car;}@Getter@Setterpubilc class Car { @Lenght(min=2, max=10, message=\"别超出范围\") private String name;} 那显然对Car类的name校验是没有成功，其没有生效。需要在Person类下 car字段上打上@Valid 标志级联检验 12345678910@Getter@Setterpubilc class Person { @Lenght(min=2, max=10, message=\"别超出范围\") private String name; private Integer age; @Valid // 这里加上 @Valid private Car car;} @Validated和@Valid这两个都是可以用来校验的，使用的场景和功能上有点区别，但是总体上是差不多的，两者都可以用来开启校验。@Valid是Java提供的一种标准，而@Validated是Spring对@Valid的扩展，所以说两者是很相似的。一般会使用@Validated来开启验证，而@Valid则用在级联检验上 自定义校验注解 编写注解类 12345678910111213141516@Documented // 注解里的注释加入文档@Retention(RetentionPolicy.RUNTIME) // 注解保留到运行阶段@Target({ElementType.TYPE, ElementType.FIELD}) // 目标使用类上和方法上@Constraint(validatedBy = PasswordValidator.class) // 关联逻辑类，编写具体逻辑判断（没有指定的话会报HV000030错）public @interface PasswordEqual { int min() default 4; int max() default 6; String message() default \"password are not equal\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {};} 关联注解类(具体判断逻辑) 1234567891011121314151617181920212223/** * 需要实现ConstraintValidator并需要两个参数 * 第一个参数是指定注解类 第二个参数：自定义注解修饰的目标的类型 * 需要覆盖两个方法initialize()和isValid() */public class PasswordValidator implements ConstraintValidator&lt;PasswordEqual, PersonDTO&gt; { private int min; private int max; @Override public void initialize(PasswordEqual constrainAnnotation) { this.min = constrainAnnotation.min(); this.max = constrainAnnotation.max(); } @Override public boolean isValid(PersonDTO personDTO, ConstraintValidatorContext constraintValidatorContext) { String password1 = personDTO.getPassword1(); String password2 = personDTO.getPassword2(); boolean match = password1.equals(password2); return match; }} 使用在需要校验的类上 12345678@Builder@Getter@PasswordEqual(min=1) // 这里使用public class PersonDTO { private String password1; private String password2;} 相关异常HV000030HV000030: No validator could be found for type原因是注解类PasswordEqual没有与关联类PasswordValidator， 1@Constraint(validatedBy = PasswordValidator.class) HV000028HV000028: Unexpected exception during isValid call原因是PasswordValidator的方法isValid出现异常了，具体报错需要打断点分析即可。 1234567@Overridepublic boolean isValid(PersonDTO personDTO, ConstraintValidatorContext constraintValidatorContext) { String password1 = personDTO.getPassword1(); String password2 = personDTO.getPassword2(); boolean match = password1.equals(password2); return match;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"},{"name":"annotation","slug":"annotation","permalink":"https://www.zeffon.cn/tags/annotation/"}]},{"title":"Java JPA 原生SQL和JPQL","date":"2020-03-31T09:05:41.000Z","path":"posts/5d8d4396.html","text":"记录Java JPA使用jPQL和原生SQL的方式获取数据。 前言SpringBoot项目中，通常会使用jpa或者mybatis ORM框架来作为Java持久层。或许我们习惯性地认为JPA不能处理复杂的SQL语句。其实这是不太正确地对JPA的认识。Java jpa其实是非常强大的，它是有多种方式操作数据库来获取数据，常见是Repository持久层的方法命名规则来获取数据。这种是大家最常见的使用方式，它对于简单的SQL语句真的非常方便，面对复杂SQL查询可能把写方法名写得很长很不优雅。这时候我们可以采取其他的方式来获取数据–原生SQL和JPQL。 在 spring data jpa 方法命名规则 一文中介绍jpa方法的命名规则。 正文模型关系有四张数据表：3张业务表activity、coupon、category，1张中间表coupon_category。对此在Java中需要3个模型(中间表无业务操作，故不需要建立模型)。 Activity &lt;— 一对多 —&gt; Coupon &lt;— 多对多(中间表coupon_category) —&gt; Category 1. 活动模型 12345678910111213@Entity@Getter@Setterpublic class Activity { @Id private Long id; private String title; private String name; // 导航属性 1对多关联Coupon模型中的activityId字段 @OneToMany(fetch = FetchType.LAZY) @JoinColumn(name = \"activityId\") private List&lt;Coupon&gt; couponList;} 2. 优惠券模型 1234567891011121314@Entity@Getter@Setterpublic class Coupon { @Id private Long id; private Long activityId; private String title; private Date startTime; private Date endTime; // 导航属性 多对多关联Category @ManyToMany(fetch = FetchType.LAZY, mappedBy = \"couponList\") private List&lt;Category&gt; categoryList;} 2. 分类模型 1234567891011121314@Entity@Setter@Getterpublic class Category { @Id private Long id; private String name; // 导航属性 多对多关联Coupon 加入中间表coupon_category，以category_id和coupon_id进行桥接 @ManyToMany(fetch = FetchType.LAZY) @JoinTable(name = \"coupon_category\", joinColumns = @JoinColumn(name = \"category_id\"), inverseJoinColumns = @JoinColumn(name = \"coupon_id\")) private List&lt;Coupon&gt; couponList;} 原生SQL在方法上打上@Query,并且传入nativeQuery=true和 value=\"sql原生语句\"。 传入参数方式：cid -&gt; :cid , now -&gt; :now 也可以cid -&gt; ?1 , now -&gt; ?2 (比较推荐前者，可读性比较高)123456789@Query(nativeQuery=true, value = \"select * from coupon c\\n\" + \"join coupon_category cc on c.id = cc.coupon_id\\n\" + \"join category ca on ca.id = cc.category_id\\n\" + \"join activity a on a.id = c.activity_id\\n\" + \"where c.id = :cid\\n\" + \"and a.startTime &lt; :now \\n\" + \"and a.endTime &gt; :now\\n\")List&lt;Coupon&gt; findByCategory(Long cid, Date now); 小技巧 编写@Query注解里面的SQL语句时，按住alt+enter会弹出选择框，选择Edit Generic SQL Fragment选项。随后我们进入一个SQL编写的控制面板。在这里是与@Query注解里面是同步的，有智能提示，回车也方便。 JPQLJPQL全称Java Persistence Query Language，它是一种查询语言，具有与SQL 相类似的特征，JPQL是完全面向对象的，具备继承、多态和关联等特性，和hibernate的HQL很相似。 1. 由于JPQL操作的是模型对象而不再是数据库的表，因此这里的字段属性需要与模型中的字段保持一致 1234567@Query(\"SELECT c from Coupon c\\n\" + \"join c.categoryList ca\\n\" + \"join Activity a on a.id = c.activityId\\n\" + \"where ca.id = :cid\\n\" + \"and a.startTime &lt; :now \\n\" + \"and a.endTime &gt; :now\\n\")List&lt;Coupon&gt; findByCategory(Long cid, Date now); 由于Coupon中有导航属性categoryList，可以通过模型让Coupon与Category创建多对多联系。对此在编写JPQL时就不要像原生SQL语句那样要借助中间表coupon_category 非幂等性操作首先JPQL不支持INSERT，但是UPDATE,DELETE操作是支持的。可能是jpa的理念就是更加注重别用SQL语句而原生的是可以支持INSERT,UPDATE,DELETE 加上@Modifying注解标注该操作是非查询操作，不然是会报错的。还可以加上事务@Transactional注解123456@Transactional@Modifying@Query(\"update Activity set\\n\" + \"name = :name\\n\" + \"where id = :id\")void updateTitle(Long id, String name); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"},{"name":"JPA","slug":"JPA","permalink":"https://www.zeffon.cn/tags/JPA/"}]},{"title":"Java正则表达式","date":"2020-03-23T09:26:37.000Z","path":"posts/397f8d1b.html","text":"记录Java正则表达式的使用以及提取HTML文本信息 前言正则表达式定义一个搜索模式的字符串，我们可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。在Java中，java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher Pattern。 Pattern是一个正则表达式经编译后的表现模式。Matcher的一个对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。所以在使用Java正则表达式时，需要先有一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后实例一个Matcher对象在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 正文正则表达式语法 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符 ^ 从字符开始匹配 $ 从字符末尾匹配 * 匹配0次或者无限多次 + 匹配1次或者无限多次 ? 匹配0次或者1次。当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是非贪心的。非贪心取短，贪心取长 [] []里面的关系是或关系 [^] []内的^是非字符, 表示取反 [-] []内的-是连续字符, 表示字符连续下去 . 匹配除换行符\\n之外其它所有字符 \\d 匹配数字字符, 等同于匹配[0-9] \\D 匹配非数字字符, 等同于匹配[^0-9] \\w 匹配任何字类字符, 包括下划线, 等同于匹配[A-Za-z0-9_] \\W 匹配任何非单词字符, 等同于匹配[^A-Za-z0-9_] \\s 匹配任何空白字符，包括空格、回车、制表符、换页符等。等同于匹配[\\f\\n\\r\\t\\v] \\S 匹配任何非空白字符。等同于匹配[^\\f\\n\\r\\t\\v] Java 在线表达式工具 Pattern类和Matcher类java正则表达式通过java.util.regex包下的Pattern类与Matcher类实现。 通过正则表达式创建模式对象Pattern。 通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。 通过匹配对象 Matcher，根据正则表达式操作字符串。 Pattern常见API split() 在此模式的匹配周围拆分给定的输入序列。返回的是String[]数组 matcher() 创建一个匹配器，该匹配器将使给定输入与此模式匹配 compile() 将给定的正则表达式编译为模式123456789101112// Pattern.matcher(String regex,CharSequence input) 用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.Boolean res1 = Pattern.matches(\"\\\\d+\",\"123\"); // 返回trueBoolean res2 = Pattern.matches(\"\\\\d+\",\"123abc\"); // 返回false,需要匹配到所有字符串才能返回true,这里abc不能匹配到// split() 在此模式的匹配周围拆分给定的输入序列。返回的是String[]数组Pattern pattern = Pattern.compile(\"\\\\d+\");String[] res = pattern.split(\"年龄:18手机:13800000000\"); // 结果： [年龄:, 手机:]// 返回pattern对象(\\d+) 也就是返回该Matcher对象是由哪个Pattern对象的创建的Pattern pattern = Pattern.compile(\"\\\\d+\");Matcher matcher = pattern.matcher(\"123abc123\");Pattern res = matcher.pattern(); Matcher常见API start() 返回上一个匹配项的起始索引 end() 返回最后一个匹配字符后的偏移量 find() 尝试查找与模式匹配的输入序列的下一个子序列 group() 返回在上一个匹配操作期间给定组捕获的输入子序列123456Pattern p = Pattern.compile(\"\\\\d+\");Matcher m1 = p.matcher(\"abc123efg\");Boolean a1 = m1.find(); // 匹配到了123, 结果: trueInteger a2 = m1.start(); // 结果: 3,返回的是123中1的起始索引Integer a3 = m1.end(); // 结果: 6,返回的是123后的偏移量String a4 = m1.group(); // 结果: 123 爬虫案例HTML爬虫思路: 明确自己想要爬去的网站，获取它的url 获取数据：根据想爬取的信息在网站定位标签 分析数据：分析自己所获取到的信息，进行正则匹配 数据精炼：通过列表、字典的操作，将数据精炼出来 保存处理：对所精炼的数据保存至数据库 在定位到自己所需要的HTML标签后，需要获取标签内的所有字符。在正则表达式有三种方式可以获取所有字符：/w/W 、 /s/S 和 . 这里以获取腾讯视频首播影院–名称和简介为例([\\\\s\\\\S]*?)中\\\\s两个\\是在Java需要一个\\来转义。[]内是匹配所有字符，*是匹配0次或者无限多次，?是非贪婪模式，()是将其进行分组处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.zeffon.bait;import org.junit.jupiter.api.Test;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.util.ObjectUtils;import org.springframework.web.client.ResourceAccessException;import org.springframework.web.client.RestTemplate;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 获取腾讯视频首播影院--名称和简介 * Create by Zeffon on 2020/3/27 */public class TenxunTest { @Test public void fetch() { String html = fetchHtml(); List&lt;String&gt; res = analysis(html); System.out.println(Arrays.toString(res.toArray())); } private String fetchHtml() { String url = \"https://v.qq.com/channel/movie\"; RestTemplate restTemplate = new RestTemplate(); setEncode(restTemplate); // 解决中文乱码问题 String html = null; try { html = restTemplate.getForObject(url, String.class); } catch (ResourceAccessException e) { System.out.println(\"连接校园网超时\"); } return html; } private List&lt;String&gt; analysis(String html) { String rootPattern = \"&lt;div class=\\\"figure_detail figure_detail_two_row \\\"&gt;([\\\\s\\\\S]*?)&lt;/div&gt;\"; Pattern pattern = Pattern.compile(rootPattern); Matcher matcher = pattern.matcher(html); List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 获取到所匹配的分组数据 while (matcher.find()) {// System.out.println(matcher.group(1)); String content = matcher.group(1); String title = titleFetch(content); String desc = descFetch(content); String s = \"title: \" + title + \" \" + \"desc: \" + desc; list.add(s); } return list; } /** * 获取到一条数据的格式如下： * &lt;a href=\"https://v.qq.com/x/cover/mzc00200i3sxjmo/d0936y5t23f.html\" class=\"figure_title figure_title_two_row bold\" title=\"我当摸金校尉的那些年\" _stat=\"movie_v3_hot:title:我当摸金校尉的那些年\" target=\"_blank\"&gt;我当摸金校尉的那些年&lt;/a&gt; * * &lt;div class=\"figure_desc\" title=\"电影再现正宗摸金范儿\"&gt;电影再现正宗摸金范儿 * 对此，我们需要根据对应内容的获取做不同正则表达式，以准确地定位到相关的匹配内容 */ private String titleFetch(String html) { String titlePattern = \"target=\\\"_blank\\\"&gt;([\\\\s\\\\S]*?)&lt;/a&gt;\"; Pattern pattern = Pattern.compile(titlePattern); Matcher matcher = pattern.matcher(html); if (matcher.find()) { return matcher.group(1); } return \"\"; } private String descFetch(String html) { String descPattern = \"&lt;div class=\\\"figure_desc\\\" title=\\\"([\\\\s\\\\S]*?)\\\"&gt;\"; Pattern pattern = Pattern.compile(descPattern); Matcher matcher = pattern.matcher(html); if (matcher.find()) { return matcher.group(1); } return \"\"; } private void setEncode(RestTemplate restTemplate) { if (null == restTemplate || ObjectUtils.isEmpty(restTemplate.getMessageConverters())) { return; } List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); for (int i = 0; i &lt; messageConverters.size(); i++) { HttpMessageConverter&lt;?&gt; httpMessageConverter = messageConverters.get(i); if (httpMessageConverter.getClass().equals(StringHttpMessageConverter.class)) { messageConverters.set(i, new StringHttpMessageConverter(StandardCharsets.UTF_8)); } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"npm安装node-sass的报错","date":"2020-03-19T00:13:09.000Z","path":"posts/87b03c86.html","text":"记录npm安装node-sass的报错处理 前言昨晚在跑vue项目时，由于换了一台win10的电脑，竟然报了一些错误。原因由npm install 中依赖包的node-sass模块引起的。其中有需要python.exe环境，node-sass拉取失败问题。 正文报错分析第一个是python.exe，因此我们需要安装python环境。注意是需要python2的环境，并且需要放在C盘根目录 第二个是拉取不下来node-sass。node-sass是从github拉取的，可能会受网络问题的影响，使用npm一直从github拉取不下来node-sass,所以更换了思路使用淘宝镜像来拉取。 安装python2环境 需要下载python2的环境(需要在管理员的cmd操作),所以安装windows-build-tools 1$ npm install --global windows-build-tools 安装的python2目录是默认在C:\\Users\\Admin\\.windows-build-tools目录，需要将他移动放在C盘根目录因为npm 拉取时默认读取的是C:\\python2\\python.exe 设置一下Path环境变量 node-sass拉取失败问题 使用淘宝源拉取node-sass1$ npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ 重启项目 先删除之前安装的依赖包，将项目根目录下的node-mudules整个删除 重新安装依赖包 1$ npm install 启动项目 1npm run server document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"npm","slug":"npm","permalink":"https://www.zeffon.cn/tags/npm/"}]},{"title":"centOS7安装mariaDB","date":"2020-03-14T08:54:28.000Z","path":"posts/342b847a.html","text":"记录一下使用离线的方式在CentOS7中安装mariaDB 10.4.x 前言MariaDB是开源关系数据库，是MySQL的原始开发人员制作，并保证保持开源，可以说是MySQL的孪生兄弟。随着甲骨文收购了MySQL，并且半闭源Java，所以MySQL存在着闭源的潜在危险。因此之前MySQL的原班人马采用MariaDB这个分支来避免风险。MariaDB是完全兼容于MySQL的，包括API和命令行。 正文下载RPM包 安装7个所需的RPM包，这些包都可以在MariaDB网站上找到 选择client、common、compat、server包时，版本要一致 逐步安装RPM包(一定要按顺序) 使用yum安装所需的所有依赖项 1$ yum install rsync nmap lsof perl-DBI nc 安装jemalloc-3.6.0-1.el7.x86_64.rpm 1$ rpm -ivh jemalloc-3.6.0-1.el7.x86_64.rpm 安装jemalloc-devel-3.6.0-1.el7.x86_64.rpm 1$ rpm -ivh jemalloc-devel-3.6.0-1.el7.x86_64.rpm 安装5个剩下的包(要按先后顺序来) 12345$ rpm -ivh MariaDB-common-10.4.12-1.el7.centos.x86_64.rpm \\MariaDB-compat-10.4.12-1.el7.centos.x86_64.rpm \\MariaDB-client-10.4.12-1.el7.centos.x86_64.rpm \\galera-4-26.4.3-1.rhel7.el7.centos.x86_64.rpm \\MariaDB-server-10.4.12-1.el7.centos.x86_64.rpm 在安装MariaDB-common-10.4.12-1.el7.centos.x86_64.rpm时，可能与较旧的MariaDB软件包冲突。我们需要删除它们并重新安装原始rpm。#rpm -ivh MariaDB-10.1.21-centos7-x86_64-common.rpmwarning: MariaDB-10.1.21-centos7-x86_64-common.rpm: Header V4 DSA/SHA1 Signature, key ID 1bb943db: NOKEYerror: Failed dependencies: mariadb-libs &lt; 1:10.1.21-1.el7.centos conflicts with MariaDB-common-10.1.21-1.el7.centos.x86_64一个警告缺少导入MariaDb的key 和 与mariadb-libs包冲突了 解决报错问题1. 卸载冲突的mariadb-libs先搜索 12$ rpm -qa | grep mariadb-libs mariadb-libs-5.5.60-1.el7_5.x86_64 进行卸载 1$ rpm -ev --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 2. 导入MariaDb的key 1$ rpm --import http://yum.mariadb.org/RPM-GPG-KEY-MariaDB 3. 在安装Galera软件包时，依赖软件包的安装可能会发生冲突。这是错误消息： error: Failed dependencies: libboost_program_options.so.1.53.0()(64bit) is needed by galera-25.3.19-1.rhel7.el7.centos.x86_64The dependencies for Galera package is: libboost_program_options.so.1.53.0 4. 需要安装boost-devel依赖环境 1$ yum install boost-devel.x86_64 5. 继续执行安装5个剩下的包命令时，会再次报缺失libaio包错误 6. 下载并安装 libaio包 (此步骤在安装10.4.8+需要) 12$ wget http://mirror.centos/6/os/x86_64/Packages/libaio-0.3.107-10.e16.x86_64.rpm$ rpm -ivh libaio-0.3.107-10.e16.x86_64.rpm 7. 最后执行安装5个剩下的包命令，等待下载好就完成了 运行并配置MariaDB 启动MariaDB（服务名是与MySQL一样的） 1$ service mysql start 安全配置(设置密码) 1$ mysql_secure_installation 初始化时是没有密码的，直接回车Enter current password for root (enter for none) 不需要权限切换Switch to unix_socket anthentication [Y/n] n 是否更改密码Change the root password? [Y/n] Y 设置新密码New password: yourPassword 确认密码Re-enter new password: yourPassword 是否移除匿名用户（安全起见可以删除）Remove anonymous users? [Y/n] Y 是否允许远程登录(也可以设置n，如果后面需要远程连接时也可以修改)Disallow root login remotely? [Y/n] Y 是否删除test数据库（留着也好）Remove test database and access to it? [Y/n] n 重新加载tables的内容Reload privilege tables now? [Y/n] Y 远程ip登录如果设置允许就不需要下面操作了。如果在配置MariaDB步骤9时，设置不允许远程登录时，可使用以下进行修改。 进入MariaDB控制台 1$ mysql -u root -p 需要将localhost改为%,让外网能访问 1$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'yourPassword' WITH GRANT OPTION; 刷新权限 1$ FLUSH PRIVILEGES; 在线安装 除了离线使用下载的安装包进行安装之外，也可以使用yum的方式进行在线安装 win安装 win安装比较简单，直接下MSI包一键安装即可 文献参考MariaDB官网 - MariaDB Installation document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mariaDB","slug":"mariaDB","permalink":"https://www.zeffon.cn/tags/mariaDB/"}]},{"title":"centOS7安装mysql","date":"2020-03-07T08:56:18.000Z","path":"posts/8ffccda5.html","text":"最近在腾讯云新弄了一台云服务器(CentOS 7)，记录在上面普通安装Mysql服务的过程。 前言最近在腾讯云新弄了一台云服务器(CentOS 7)，记录在上面普通安装Mysql服务的过程。本教程适合在CentOS 7上安装mysql5.7以上的版本，如果需要安装Mysql5.6以下版本可以参考官网教程在之前博客中有记录使用docker的安装教程Docker安装Mysql和Redis 正文添加MySQL Yum存储库 第一种方法：在MySQL Yum存储库选择并下载适用于你平台的发行包 第二种方法：使用wget直接下载指定版本(这里指定下载5.7版本) 1$ wget http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm 安装yum发行包 使用以下命令安装下载的发行包，并替换platform-and-version-specific-package-name为下载的包的名称1$ rpm -Uvh platform-and-version-specific-package-name.rpm 例如，这里下载的发行包是mysql57-community-release-el7-10.noarch.rpm1$ rpm -Uvh mysql57-community-release-el7-10.noarch.rpm 安装MySQL 通过以下命令安装MySQL(安装过程比较久，需要慢慢等待)1$ yum install mysql-community-server 启动MySQL 使用命令启动Mysql 123$ systemctl start mysqld.service或者$ service mysqld start 检查是否成功启动 123$ systemctl status mysqld.service或者$ service mysqld status 如果控制台输出如下面图片一样，则启动成功 修改密码 默认创建 ‘root’@’localhost’ 一个超级用户帐户。设置超级用户的密码并将其存储在错误日志文件中。要显示它，请使用以下命令： 1$ grep 'temporary password' /var/log/mysqld.log 通过使用生成的临时密码登录并尽快为超级用户帐户设置自定义密码，以更改root密码： 12$ mysql -uroot -p$ ALTER USER 'root'@'localhost' IDENTIFIED BY 'yourPassword!'; MySQL的 validate_password 插件默认安装。这将要求密码至少包含一个大写字母，一个小写字母，一位数字和一个特殊字符，并且密码总长度至少为8个字符。 远程ip登录 需要将localhost改为%,让外网能访问 1$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'yourPassword' WITH GRANT OPTION; 刷新权限 1$ FLUSH PRIVILEGES; 文献参考使用MySQL Yum存储库的快速指南 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.zeffon.cn/tags/mysql/"}]},{"title":"JAVA JPA 方法命名规则","date":"2020-03-04T01:54:32.000Z","path":"posts/14d38de7.html","text":"记录在SpringBoot项目使用JPA访问数据库数据时，Repository持久层的方法命名规则 前言Repository持久层的方法通过方法的命名规则会自动创建出对应的SQL语句的，因此使用JPA作为数据访问层时，我们可以通过编写对应的方法来获取到数据库的数据，而不需要编写SQL语句，相比于Mybatis，这样简化编码流程，提高了开发效率，但也是有局限性的。其无法应对太复杂的SQL语句，同时也会造成方法的命名太长而不优雅。但是编写简单的SQL时，的确非常有助于我们开发。 正文 关键字 方法命名 sql where字句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equals findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id &lt; ? LessThanEquals findByIdLessThanEquals where id &lt;= ? GreaterThan findByIdGreaterThan where id &gt; ? GreaterThanEquals findByIdGreaterThanEquals where id &gt; = ? After findByIdAfter where id &gt; ? Before findByIdBefore where id &lt; ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike where name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name &lt;&gt; ? In findByIdIn(Collection&lt;?&gt; c) where id in (?) NotIn findByNameNot where name &lt;&gt; ? True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) top findTop100 top 10/where ROWNUM &lt;=10 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"},{"name":"JPA","slug":"JPA","permalink":"https://www.zeffon.cn/tags/JPA/"}]},{"title":"java事务传播","date":"2020-02-18T10:49:48.000Z","path":"posts/d5f8033c.html","text":"记录7个Java事务传播属性的区别 前言1@Transactional(propagation = Propagation.REQUIRED) 在Java中与数据层交互时，通常会使用事务，使用@Transactional注解的propagation用来设置事务的传播行为 事务的传播行为：一个方法运行在了一个开启事务的方法中，当前方法是使用依附的方法事务还是使用自身的事务 Propagation propagation() default Propagation.REQUIRED; // Propagation默认使用REQUIRED级别 正文事务中常用就两种REQUIRED和SUPPORTS REQUIREDPropagation propagation() default Propagation.REQUIRED; // Propagation默认使用REQUIRED级别 12@Transactional(propagation = Propagation.REQUIRED)// Support a current transaction, create a new one if none exists. REQUIRED : 使用当前的事务，如果当前没有事务，则自己新建一个事务，子方法时必须运行在一个事务中的; 如果当前存在事务，则加入这个事务中，成为一个整体。 主要用于：增、删、改操作 SUPPORTS123@Transactional(propagation = Propagation.SUPPORTS)// Support a current transaction, execute non-transactionally // if none exists. SUPPORTS : 如果当前有事务，则使用事务，如果当前没有事务，则不使用事务。 主要用于：查操作 MANDATORY12@Transactional(propagation = Propagation.MANDATORY)// Support a current transaction, throw an exception if none exists. MANDATORY : 该传播属性强制必须存在一个事务，如果不存在，则抛出异常 REQUIRED_NEW123@Transactional(propagation = Propagation.REQUIRED_NEW)// Create a new transaction, and suspend the current transaction // if one exists. REQUIRED_NEW : 如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用; 如果当前没有事务，则同REQUIRED NOT_SUPPORTED123@Transactional(propagation = Propagation.NOT_SUPPORTED)// Execute non-transactionally, suspend the current transaction// if one exists. NOT_SUPPORTED : 如果当前有事务，则把事务挂起，自己不使用事务去运行数据操作 主要用于：查操作 NEVER123@Transactional(propagation = Propagation.NEVER)// Execute non-transactionally, throw an exception// if a transaction exists. NEVER : 如果当前有事务存在，则抛出异常 NESTED123@Transactional(propagation = Propagation.NESTED)// Execute within a nested transaction if a current transaction // exists, behave like {@code REQUIRED} otherwise. NESTED : 如果当前有事务，则开启子事务(嵌套事务)，嵌套事务是独立提交或者回滚; 如果当前没有事务，则同REQUIRED。但是如果主事务提交，则会携带子事务一起提交。如果主事务回滚，则子事务一起回滚。相反，子事务异常，则主事务可以回滚或者不回滚(捕捉异常，则不回滚；不捕捉，则回滚) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"实现二叉堆-最大堆","date":"2020-01-07T08:27:31.000Z","path":"posts/c296b2d8.html","text":"前言 二叉堆分为最小堆和最大堆 最大堆：堆中某个节点的值总是不大于其父节点的值(即根节点是最大值)，最小堆则反之。 堆是平衡二叉树，并且堆是从1开始计数的，按层数遍历的方式给节点标上顺序。 本文基于数组实现最大堆 正文添加向二叉堆添加一个元素，只需把它放在最后一个位置的下一个，然后该节点与父节点进行大小比较。如果大于父节点的值，需要将其进行上浮，直至到合适位置；否则不需要浮动。往堆中添加一个元素 1234567 79 / \\ 56 49 / \\ / \\ 22 29 34 40 / 10 现在添加 61，放在10的下一个位置 1234567 79 / \\ 56 49 / \\ / \\ 22 29 34 40 / 10 61 与父节点29进行比较，大于父节点的值，交换两者的位置，需要进行上浮 1234567 79 / \\ 56 49 / \\ / \\ 61 29 34 40 / \\10 22 61的节点再与父节点56比较，大于需要上浮 1234567 79 / \\ 61 49 / \\ / \\ 56 29 34 40 / \\10 22 现在满足了 删除删除操作是将堆中最大的元素弹出，根节点(1位置)与最后一个节点的位置互换。size大小减一，后将新的根节点下沉到合适位置。删除堆中最大值 1234567 79 / \\ 56 49 / \\ / \\ 22 29 34 40 / 10 79与10交换位置 1234567 10 / \\ 56 49 / \\ / \\ 22 29 34 40 / 79 size大小减去一 12345 10 / \\ 56 49 / \\ / \\ 22 29 34 40 父节点10与左右节点中最大值节点56交换位置 12345 56 / \\ 10 49 / \\ / \\ 22 29 34 40 同理，10与29交换位置 12345 56 / \\ 29 49 / \\ / \\ 22 10 34 40 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MaxHeap { private int data[]; // 存放堆数据的数组 private int size; //当前堆的大小 private int capacity; //堆的最大容量 // 初始化时 public MaxHeap(int capacity){ data = new int[capacity+1]; this.size = 0; this.capacity = capacity; } //向堆里面插入元素 public void insert(int item){ if(size == capacity){ System.out.println(\"The heap is full\"); return; } data[size+1] = item; // 将元素放在最后一个的下一个 size++; shiftUp(size); // 将元素上浮至合适位置 } //堆插入元素时的元素上浮 private void shiftUp(int k) { while(k &gt; 1 &amp;&amp; data[k/2] &lt; data[k]){ swap(data, k/2, k); k /= 2; } } //删除堆的最大元素 public int extractMax(){ if(size == 0){ System.out.println(\"The heap can not be null\"); return -1; } int ret = data[1]; swap(data, 1, size); // 第一个与最后一个元素交换位置 size--; shiftDown(1); // 下沉到合适位置 return ret; } //堆删除元素时的元素下沉 private void shiftDown(int k) { while(2*k &lt;= size){ int j = 2*k; // 在此轮循环中，data[k]和data[j]交换位置 if(j + 1 &lt;= size &amp;&amp; data[j+1] &gt; data[j]){ j += 1; } if(data[k] &gt; data[j]) break; //元素下移 swap(data, k, j); k = j; } } //堆排序 public void heapSort(int arr[], MaxHeap heap){ for(int i = 0; i &lt; arr.length; i++){ heap.insert(arr[i]); } for(int i = arr.length - 1; i &gt;= 0 ; i--){ arr[i] = heap.extractMax(); } } private void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉树的遍历方式","date":"2020-01-01T05:57:27.000Z","path":"posts/d5b5365e.html","text":"前言 今天是2020年的第一天，希望在新的一年有所收获… 主要总结一下二叉树的遍历方式及其递归和非递归的实现 正文前序遍历LeetCode-144.二叉树前序遍历 递归实现 12345678910111213141516171819class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); helper(root, res); return res; } public void helper(TreeNode root, List&lt;Integer&gt; res) { if (root != null) { res.add(root.val); if (root.left != null) { helper(root.left, res); } if (root.right != null) { helper(root.right, res); } } }} 非递归实现 1234567891011121314151617181920class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode cur = stack.pop(); res.add(cur.val); if(cur.left != null) stack.push(cur.left); if(cur.right != null) stack.push(cur.right); } return res; }} 中序遍历LeetCode-94. 二叉树的中序遍历 递归实现 12345678910111213141516171819class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); helper(root, res); return res; } public void helper(TreeNode root, List&lt;Integer&gt; res) { if (root != null) { if (root.left != null) { helper(root.left, res); } res.add(root.val); if (root.right != null) { helper(root.right, res); } } }} 非递归实现 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if(cur != null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); res.add(cur.val); cur = cur.right; } } return res; }} 后序遍历LeetCode-145.二叉树后序遍历 递归实现 12345678910111213141516171819class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); helper(root, res); return res; } public void helper(TreeNode root, List&lt;Integer&gt; res) { if (root != null) { if (root.left != null) { helper(root.left, res); } if (root.right != null) { helper(root.right, res); } res.add(root.val); } }} 非递归实现 1234567891011121314151617181920212223242526272829class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if(cur != null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); if(cur.right == null || pre == cur.right){ res.add(cur.val); pre = cur; cur = null; } else { stack.push(cur); cur = cur.right; } } } return res; }} 层次遍历LeetCode-102.二叉树的层次遍历 递归实现 1234567891011121314151617181920212223class Solution { List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if (root == null) { return levels; } helper(root, 0); return levels; } public void helper(TreeNode node, int level) { if (levels.size() == level) levels.add(new ArrayList&lt;Integer&gt;()); levels.get(level).add(node.val); if (node.left != null) helper(node.left, level + 1); if (node.right != null) helper(node.right, level + 1); }} 非递归实现 123456789101112131415161718192021222324252627282930313233class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int levelNum = 1; while(!queue.isEmpty()){ int newLevelNum = 0; ArrayList&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; levelNum; i ++){ TreeNode node = queue.remove(); level.add(node.val); if(node.left != null){ queue.add(node.left); newLevelNum ++; } if(node.right != null){ queue.add(node.right); newLevelNum ++; } } res.add(level); levelNum = newLevelNum; } return res; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"hexo-add-music","date":"2019-12-16T01:01:31.000Z","path":"posts/f6280cee.html","text":"欢乐的时光怎么能少了音乐相伴呢，所以在文章中添加音乐也是一件值得享受的事，而且在Hexo添加音乐也是很方便。 前言MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。 正文在Hexo添加音乐很简单，首先先下载相关的插件，在配置开启插件开关，然后在需要添加音乐的文章中添加相关的代码就行了。 首先先看看效果 单首歌曲模式 歌单模式 安装步骤 安装hexo-tag-aplayer插件 1$ npm install hexo-tag-aplayer --save 在Hexo根配置文件_config.yml中设置开关 12aplayer: meting: true 直接在文中添加音乐模板比如上面单首歌曲模式 1{% meting \"1363948882\" \"netease\" \"song\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %} 歌单模式 1{% meting \"801641548\" \"netease\" \"playlist\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %} 如果无法在网页显示出音乐模板，可能是因为刚刚下载插件，没有进行重新编译 123$ hexo clean$ hexo g$ hexo s 音乐模板说明 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 歌曲id和歌单id获取比如获取网易云音乐平台 获取歌曲id 获取歌单id document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Hexo搭建blog","date":"2019-12-14T11:50:20.000Z","path":"posts/2d212f7.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Java 控制反转(IoC)和依赖注入(DI)","date":"2019-12-06T11:50:20.000Z","path":"posts/15bd38ef.html","text":"控制反转(Inversion of Control)和依赖注入(Dependency Injection) 前言控制反转和依赖注入的概念可能有些抽象，我细想一下以往的开发过程中，也是不知道它们实际的用途是什么，对它们的理解也是仅仅有个模糊的影子而已。对此再次提及它们时，我不能再对此视而不见了。所以在网上查阅一些资料，包括一些大神写的博客，希望自己能在这次有比较有好的认识。如果有理解不到位或者理解错的地方，望大家多多指正。^_^ 正文控制反转IoC首先，我们先明白什么是IoC？在Java开发中，IoC是意味着将你设计好的对象交给了IoC容器进行控制，而不再是传统的在你的对象内部进行控制。所谓的控制反转就是要去反转控制权。而理解好IoC需要明白在这控制中,谁控制谁，控制着什么？为什么是反转呢？还有哪些方面的控制被反转了？ 谁控制谁，控制什么？在传统的面向对象编程设计，我们需要直接在对象内部通过new的方式进行创建对象，这种属于是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC容器控制了对象；控制什么？那就是主要控制了外部资源获取。传统的面向对象编程设计 IoC容器 为什么是反转呢？有反转就有正转。在传统的面向对象编程设计中是由我们自己在对象中主动控制去直接new来获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转。 哪些方面的控制被反转了？依赖对象的获取被反转了。原本是houseService对象需要主动获取houseDao对象的，现在变成houseDao对象注入到houseService对象中。houseService对象不需要创建什么，IoC容器会帮它查找并注入依赖对象houseDao对象。 IoC的好处 IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。在单一职责原则的设计下，很少有单独一个对象就能完成的任务。大多数任务都需要复数的对象来协作完成，这样对象与对象之间就有了依赖。一开始对象之间的依赖关系是自己解决的，需要什么对象了就New一个出来用，控制权是在对象本身。但是这样耦合度就非常高，可能某个对象的一点小修改就会引起连锁反应，需要把依赖的对象一路修改过去。 这样会导致代码高度和并且难以维护和调试。为了避免这种情况，需要将对象内部的控制权反转到外部(IoC容器)。有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了主从换位的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC和DI DI—Dependency Injection，即依赖注入：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： 谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 总结控制反转是一种面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见一种的方式叫做依赖注入。控制反转不是一种技术，而是一种思想，其基本思想是：借助于第三方(IoC容器)实现具有依赖关系的对象之间的解耦。控制反转作为Spring的核心，让IoC容器通过依赖注入的方式使得创建依赖对象的控制权由对象转移到IoC容器 参考文献IoC 之 2.1 IoC基础 ——跟我学Spring3 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"Linux中的环境变量配置文件","date":"2019-11-30T04:00:00.000Z","path":"posts/aa1859fd.html","text":"前言平时在linux上安装一些应用，有时候需要设置环境变量，环境变量按照其作用范围不同大致可以分为系统级环境变量和用户级环境变量。 系统级环境变量：每一个登录到系统的用户都能够读取到系统级的环境变量； 用户级环境变量：每一个登录到系统的用户只能够读取属于自己的用户级的环境变量； 正文系统级环境变量1. /etc/profile 在系统启动后第一个用户登录时运行，并从/etc/profile.d目录的配置文件中搜集shell的设置，使用该文件配置的环境变量将应用于登录到系统的每一个用户。123456789# /etc/profile## System wide environment and startup programs, for login setup# Functions and aliases go in /etc/bashrc## It's NOT a good idea to change this file unless you know what you# are doing. It's much better to create a custom.sh shell script in# /etc/profile.d/ to make custom changes to your environment, as this# will prevent the need for merging in future updates. 在该文件中添加环境变量即可，后使用以下命令可以使配置文件立刻生效。以下都是使用source来生效。1$ source /etc/profile 2. /etc/bashrc 在bash shell打开时运行，修改该文件配置的环境变量将会影响所有用户使用的bash shell。 123456789# /etc/bashrc## System wide functions and aliases# Environment stuff goes in /etc/profile## It's NOT a good idea to change this file unless you know what you# are doing. It's much better to create a custom.sh shell script in# /etc/profile.d/ to make custom changes to your environment, as this# will prevent the need for merging in future updates. 这里的bash shell有不同的类别，不同的类别所使用的环境变量配置文件也有所不同。一般情况下，非登录shell不会执行任何profile文件，非交互shell模式不会执行任何bashrc文件。 /etc/bashrc在Ubuntu和Debian中是/etc/bash.bashrc 3. /etc/environment 在系统启动时运行，用于配置与系统运行相关但与用户无关的环境变量，修改该文件配置的环境变量将影响全局。 用户级环境变量 其中/.bash_profile、/.bash_login、/.profile三个文件中往往系统中往往只存在一个，在不同的发行版中不同，如CentOS和RedHat中是`/.bash_profile，而Debian和Ubunto等系列中往往是~/.profile` 1. ~/.bash_profile(建议首选) 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. 此文件类似于/etc/profile，也是需要需要重启才会生效，/etc/profile对所有用户生效，~/.bash_profile只对当前用户生效。 2. ~/.profile 当用户登录时执行，每个用户都可以使用该文件来配置专属于自己使用的shell信息。 3. ~/.bashrc 当用户登录时以及每次打开新的shell时该文件都将被读取，不推荐在这里配置用户专用的环境变量，因为每开一个shell，该文件都会被读取一次，效率肯定受影响。 此文件类似于/etc/bashrc，不需要重启生效，重新打开一个bash即可生效， /etc/bashrc对所有用户新打开的bash都生效，但~/.bashrc只对当前用户新打开的bash生效。 4. ~/.bash_logout 当每次退出系统(退出bash shell)时执行该文件。 注意：Linux系统使用 $VARIABLE_NAME 访问环境变量，多个环境变量之间使用 “:”分隔，Windows系统使用 %VARIABLE_NAME% 访问环境变量，多个环境变量之间使用 ; 分隔。 联系 ~/.bash_profile 是交互式、login 方式进入bash 运行的； ~/.bashrc 是交互式 non-login 方式进入bash 运行的； 通常二者设置大致相同，所以通常前者会调用后者。 设置生效：可以重启生效，也可以使用命令：source 执行顺序一般情况下，Linux加载环境变量配置文件的执行顺序为： 12345678910111213 -------- 登陆 -------- | | | 登陆shell | | | /etc/profile | | | /etc/profile.d | | | ~/.bash_profile | | | ~/.bash_login | |~/.bashrc &lt;---------- ~/.profile 参考文献JeanCheng Linux中profile、bashrc、/.bash_profile、/.bashrc、~/.bash_profile之间的区别和联系以及执行顺序 细雨微光 - linux命令（56）：环境变量：/etc/profile、/etc/bashrc 、/.profile、/.bashrc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linux","slug":"linux","permalink":"https://www.zeffon.cn/tags/linux/"}]},{"title":"Heroku 搭建 V2ray","date":"2019-11-25T04:00:00.000Z","path":"posts/397734e7.html","text":"前文Heroku 是一个支持多语言的PaaS。简单来说这是一个可以免费快速将自己的应用部署在上面的云平台。 正文搭建 首先需要有heroku账号，所以需要先注册 验证完heroku账号后，使用大神zyp997写插件ss-heroku。直接点击README.md中Deploy to Heroku图标，进行一键在Heroku进行搭建v2ray 跳转到Heroku填写信息：名称随便填写、地区选择就近的、AppName需要与前面的名称相同、ENCRYPT设置为rc4-md5加密算法，其他默认即可。 点击Deploy app进行部署完后，点击View会跳转到一个动态页面，如果能正常在浏览器查看二维码https://AppName.herokuapp.com/qr_img/v2.png，则部署成功了。 连接手机(Android) 下载shadowsocks 下载v2ray插件，我试过精简版的安装不了，所有选择universal通用版进行安装。 打开shadowsocks，点击右上角上的 + ，选择扫描二维码。扫描之前的二维码https://yourAppName.herokuapp.com/qr_img/v2.png，即可添加节点。 win10 下载shadowsocks 下载v2ray-plugin插件 打开shadowsocks客户端，添加一个服务器。 服务器地址 : yourAppName.herokuapp.com 端口 : 443 密码 : 密码默认为5c301bb8-6c77-41a0-a606-4ba11bbab084 加密算法 : rc4-md5 插件程序 : 插件的路径 插件选项 : path=/static;host=yourAppName.herokuapp.com;tls 或者扫描手机分享的二维码添加，再更改插件程序的路径即可 mac 待续 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"acme.sh免费申请Let's Encrypt泛域名证书","date":"2019-11-22T04:00:00.000Z","path":"posts/425caa0e.html","text":"前言使用 acme.sh 可以免费生成 Let’s Encrypt 泛域名证书，比Certbot申请方式简单易用，不需要手动设置TEXT，不需要设置定时任务申请证书。acme.sh内置每天检测证书是否过期，过期则进行自动续期。如果想用Certbot的话，在之前写过一篇免费https通配符证书申请与配置。 申请与配置 有两种方式申请 acme.sh脚本 docker镜像获取 acme.sh脚本 安装 acme.sh 123$ curl https://get.acme.sh | sh# OK# Install success! 显示则安装成功 获取相关的参数 不同的域名厂商使用的命令也不同，请参考官网 获取阿里云AccessKey的ID和Secret也就是Ali_Key和Ali_Secret 获取DNSPod的Id和Key(key也就是token) 阿里云获取证书 12345678# 替换成从阿里云后台获取的密钥$ export Ali_Key=\"xxxxxx\"$ export Ali_Secret=\"xxxxxx\"# 换成自己的域名$ acme.sh --issue --dns dns_ali -d example.com -d *.example.com# --force 强制# 命令执行后比较慢，需要等待# 需要等待两多分钟，也可以在命令添加 `--dnssleep 900` 等待90秒 DNSPod获取证书 12345# 登录DNSPod后台获取相关的密钥 https://console.dnspod.cn/account/token$ export DP_Id=\"123456\"$ export DP_Key=\"qwert2g3yuiop3\"# 换成自己的域名$ acme.sh --issue --dns dns_dp -d example.cn -d *.example.cn -bash: acme.sh: command not found$ source ~/.bashrc # 或者重启终端就可以了 证书目录 123Cert success# 证书生成成功，同时下面还有key信息# 生成的证书放在该目录下: ~/.acme.sh/example.com/ Nginx证书配置 123456789101112131415161718192021222324252627282930server { listen 443; server_name example.com; ssl on; ssl_certificate /root/.acme.sh/example.com/fullchain.cer; # 替换自己的证书 ssl_certificate_key /root/.acme.sh/example.com/example.com.key; # 替换自己的证书 ssl_trusted_certificate /root/.acme.sh/example.com/ca.cer; # 替换自己的证书 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; }}server { listen 80; server_name example.com; rewrite ^/(.*) https://$server_name$request_uri? permanent;} docker镜像获取想用docker镜像来获取证书比较方便。官方的github有详细的教程 docker运行 12345$ docker run --rm -it \\ -v \"$(pwd)/out\":/acme.sh \\ -e Ali_Key=\"xxxxxx\" \\ -e Ali_Secret=\"xxxx\" \\ neilpang/acme.sh --issue --dns dns_ali -d example.com -d *.example.com 证书位置 1-v \"$(pwd)/out:/acme.sh\" # 是映射在当前目录下的out目录，如果想更换其他目录，更换即可。 其他Nginx配置与脚本方式的配置相同。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"},{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"}]},{"title":"Docker安装Mysql和Redis","date":"2019-11-21T04:00:00.000Z","path":"posts/6e95fd19.html","text":"Docker安装请观看之前的博客内容Docker安装教程 应用安装安装 Mysql安装 mysql 5.7 版本 拉取镜像 1$ docker pull mysql:5.7 新建需要挂载文件夹 12$ mkdir /docker-data/mysql/data$ mkdir /docker-data/mysql/conf.d 在conf.d目录创建my.cnf 123456$ vi my.cnf[mysqld]skip-grant-tables# skip-grant-tables作为启动参数的作用：MYSQL服务器不加载权限判断，任何用户都能访问数据库。default-time_zone = '+8:00'# 设置北京时区 运行并挂载在本机 12345$ docker run --name mysql5.7 -p 3306:3306 \\--restart=always --privileged=true \\-v /docker-data/mysql/data:/var/lib/mysql \\-v /docker-data/mysql/conf.d:/etc/mysql/conf.d \\-e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 修改密码为空 1234567$ docker exec -it CONTAINER ID bash $ mysql -uroot -p# 不用输密码直接回车，进入mysql命令mysql&gt; use mysqlmysql&gt; select user,authentication_string,host from user; # 查看账号、密码、可连接的hostmysql&gt; update user set authentication_string='' where user='root'; #修改密码mysql&gt; flush privileges; #刷新权限 mysql&gt; select user,authentication_string,host from user; # 查看账号、密码、可连接的hostroot需要有两个host – localhost、% 并且密码不为空，没有 % 的话无法外网访问mysql&gt; CREATE USER ‘root’@’%’ IDENTIFIED BY ‘123456’; # 没有的话进行新建 注释掉my.cnf中，文件中的skip-grant-tables，重启mysql服务 123$ docker ps$ docker stop CONTAINER ID$ docker start CONTAINER ID 修改root密码 1234mysql&gt; use mysqlmysql&gt; alter user 'root'@'localhost' IDENTIFIED BY '123456';mysql&gt; alter user 'root'@'%' IDENTIFIED BY '123456';mysql&gt; flush privileges; 安装 mysql 8 版本步骤与mysql 5.7的流程相似 拉取镜像 1$ docker pull mysql:latest 新建需要挂载文件夹 12$ mkdir /docker-data/mysql8/data$ mkdir /docker-data/mysql8/conf.d 在conf.d目录创建my.cnf 1234$ vi my.cnf[mysqld]skip-grant-tablesdefault-time_zone = '+8:00' 运行并挂载在本机 1234$ docker run --name mysql8 -p 3306:3306 \\-v /docker-data/mysql8/data:/var/lib/mysql \\-v /docker-data/mysql8/conf.d:/etc/mysql/conf.d \\-e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 修改密码为空 1234567$ docker exec -it CONTAINER ID bash $ mysql -uroot -p# 不用输密码直接回车，进入mysql命令mysql&gt; use mysqlmysql&gt; select user,authentication_string,host from user; # 查看账号、密码、可连接的hostmysql&gt; update user set authentication_string='' where user='root'; #修改密码mysql&gt; flush privileges; #刷新权限 注释掉my.cnf中，文件中的skip-grant-tables，重启mysql服务 123$ docker ps$ docker stop CONTAINER ID$ docker start CONTAINER ID MYSQL 8.0内新增加mysql_native_password函数，通过更改这个函数密码来进行远程连接。mysql&gt; ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;没有 root - % 添加即可。mysql&gt; CREATE USER ‘root’@’%’ IDENTIFIED BY ‘123456’; 修改root密码 1234mysql&gt; use mysqlmysql&gt; alter user 'root'@'localhost' IDENTIFIED BY '123456';mysql&gt; ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';mysql&gt; flush privileges; 安装 redis 拉取官方的redis镜像指定版本 1$ docker pull redis:5.0.5 修改启动默认配置，官方 redis.conf 配置文件 注意需要修改四个地方： 1234bind 127.0.0.1 #注释掉这部分，用来限制redis只能本地访问protected-mode no #默认yes表示开启保护模式，用来限制redis只能本地访问appendonly yes #持久化requirepass password #密码 新建文件夹用于redis外部挂载 12$ mkdir /docker-data/redis/data$ mkdir /docker-data/redis/conf 启动redis 12345$ docker run --name my-redis -d -p 6379:6379 \\--restart=always --privileged=true \\-v /docker-data/redis/conf/redis.conf:/etc/redis/redis.conf \\-v /docker-data/redis/data:/data \\redis:5.0.5 redis-server /etc/redis/redis.conf 查看redis是否正常启动，如果没有问题就可以使用远程连接redis 1$ docker ps document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://www.zeffon.cn/tags/redis/"},{"name":"mysql","slug":"mysql","permalink":"https://www.zeffon.cn/tags/mysql/"}]},{"title":"Java 并发编程的基石","date":"2019-11-18T04:00:00.000Z","path":"posts/4daac1fc.html","text":"前文学习并发编程，对于线程与进程、线程与多线程、并行与并发、并发与高并发、同步与异步、阻塞与非阻塞之间的概念与关系，需要进一步的理解。本篇学习于慕课网悟空老师的《Java并发编程的基石》 正文线程、进程和多线程进程 指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程。 进程就是程序(这里可以理解为我们编写的代码)的真正运行实例，是资源分配的基本单位。 线程 线程是CPU的基本调度单位，每个线程执行的都是进程代码的某个片段。 在进程上下文中执行的一系列指令。 进程与线程的 联系操作系统`包 含多个进程的容器，而每个进程又都是容纳`多个线程的容器。 进程与线程的 异同 相似点：生命周期 起源不同: 计算机系统先有进程后有线程，起初只有进程，没有线程的概念。因为微处理器的的处理速度远远高于外设（键盘鼠标等等），才诞生了线程，线程的诞生是为了提高程序的运行效率 概念不同: 进程是操作系统分配资源和调度的基本单位，线程是cpu运行调度的基本单位 内存共享方式不同: 通常进程之间内存不会共享（比如浏览器不会访问视频播放软件的内存），通常需要高级技巧IDC 才能实现进程间通信实现内存共享，而线程之间的内存共享则比较容易 拥有的资源不同: 线程本身是进程的一部分，所以每个线程拥有的资源肯定少于进程，而线程之间共有的内容主要是代码片段，不共有的主要是线程的堆栈（独立的内存） 数量不同: 一个进程里面可以有很多线程，但是至少会有一个线程 开销不同: 线程的创建和终止比进程短，同一个进程内部的线程之间的切换比进程之间的切换要快，同一个进程的各个线程之间共享内存和资源文件，可以不通过内核进行通信 多线程如果一个程序允许运行两个或以上的线程，那么它就是多线程程序。多线程是指在单个程序中运行多个线程。 多线程的作用: 最主要的目的就是提高CPU利用率(1.提高处理速度 2.避免无效等待 3.提高用户体验、避免卡顿和缩短等待时间) 便于编程建模 计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台 多线程的局限: 性能问题：上下文切换带来的消耗 异构化任务(任务结构不一样)很难高效并行 带来线程安全问题：包括数据安全问题(例如i++总数不一致)以及线程带来的活跃性问题(线程饥饿、死锁)。 并行、并发和高并发并行真正的同时运行—在同一时刻，有多个任务同时执行。例如，在多核处理器上，有两个线程同时执行同一段代码。单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务。 并发 形容多个任务的执行状态 两个或多个任务可以在重叠的时间段内启动，运行和完成 并行(两个线程同时执行)一定是并发 并不一定意味着并发一定要求是并行 对并发性的简称 不同的部分可以无序或同时执行，且不影响最终的执行结果 在不同核心数的计算机上的不同表现 此时，并行和并发的概念并不同一维度上 高并发 同时有很多个请求发送给服务器系统，服务器能够同时并行处理很多请求。 高并发和多线程的联系和不同 高并发可以认为是一种状态(大量的请求同时到达我们的服务器所带来的一种结果)；多线程是一种编程方式，它是一种解决方案，它所解决的是恰恰是防止高并发带来的线程安全问题或者是性能问题。 多线程和高并发的关系：其中一种重要的解决方案 高并发并不意味着是多线程：Redis 高并发指标 QPS(Queries Per Second) 每秒查询数(每秒钟的请求数) 带宽 PV(Page View) 综合浏览量，指的是一天之内访问量 UV(Unique Visitor) 一天之内用户访问数量 IP和UV的区别 并发连接数(The number of concurrent connections) 服务器平均请求等待时间(Time per request:across all concurrent requests) 同步与异步、阻塞与非阻塞同步与异步：被调用者是否主动告诉调用者结果。阻塞与非阻塞就是程序在等待调用结果（消息，返回值）时的状态。 同步 在发出一个同步调用时，在没有得到结果之前，该调用就不返回。 同步这里指的是被调用者(也就是服务器)的行为，而不是请求方的行为。在没有得到结果之前，服务端就不返回任何结果。 异步 在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。 调用在发出之后，服务端会立刻返回，告诉调用方‘我收到你的请求了，我会处理的’。这样调用方知道被调用方已接收到请求了，就可以去执行其他命令了。 阻塞 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 我是调用者，我调用一个东西之后，结果返回前，我不能做别的事。 非阻塞 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 我是调用者，我调用一个东西之后，结果返回前，我还能做别的事。 阻塞与非阻塞站在线程状态的角度 阻塞与非阻塞站在线程发出请求(通常是HTTP请求)的角度 联系举一个烧水壶的例子进行说明。 两种水壶： 一种是把水烧开了不会提醒的。 一种是会提醒发出呜呜声响的。 同步阻塞选用不会提醒的水壶进行烧水，在烧水期间，由于我是笨，不知道水什么时候会烧好，只好坐在水壶前等待，这样就不能去做其他事情。一直在水壶前盯着，直到水壶把水烧开拿下来。 同步非阻塞选用不会提醒的水壶进行烧水，在烧水期间，我很聪明，虽然不知道什么时候会烧好，但是我能在这期间去做其他事情，只要时不时来检查一下是否烧好了就好了。烧好拿下来就好了。 异步阻塞选用会提醒的水壶进行烧水，在烧水期间，由于我比较笨和老实，我还是只能坐在水壶前，所以也不能去做其他事情。直到水壶烧开发声提醒时，才把水壶拿下来。 异步非阻塞选用会提醒的水壶进行烧水，在烧水期间，我很聪明知道时间不可浪费，我可以跑去做其他事情，等到我听到水壶烧开发声提醒时，我才过去把水壶拿下来，这样也是能完成烧水任务的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"Java 注解","date":"2019-11-07T04:00:00.000Z","path":"posts/ca104227.html","text":"前文Java注解又称为标注，是Java提供了一种原程序中的元素关联任何信息和任何元数据的途径和方法。Java中的类、方法、变量、参数、包都可以被注解。 正文Java中常见注解 @interface注解： 1234561.表示定义的是一个注解(不是类，也不是接口)；2.成员要以无参无异常的方式声明；3.可以用default为成员指定一个默认值；4.成员类型受限制，合法的类型包括原始数据类型和String(常用),Class,Annotation,Enumeration；5.如果注解只有一个成员，则该成员名必须为value()，在使用时可忽略成员名和赋值号(=)；6.注解类可以没用成员，此时该注解被称为“标识注解”； 元注解 123456789@Target(ElementType.ANNOTATION_TYPE) 注解的作用域TYPE //Class,interface 类和接口FIELD //Field declaration 字段声明METHOD //Method declaration 方法声明PARAMETER //Formal parameter declaration 参数声明CONSTRUCTOR //Constructor declaration 构造方法LOCAL_VARIABLE //Local variable declaration 局部变量ANNOTATION_TYPE //Annotation type declaration 注解类型声明PACKAGE //Packagedeclaration 包声明 123456789@Retention(RetentionPolicy.RUNTIME) 注解的生命周期SOURCE //Annotations are to be discarded by the compiler //只在源代码显示，编译时会放弃CLASS //Annotations are to be recorded in the class file by the compiler. //But need not be retained by the VM at runtime. This is the default behavior. //编译时会记录到class中，运行时忽略RUNTIME //Annotations are to be recorded in the class file by the compiler and retained //by the VM at runtime, so they may be read reflectively. //运行时存在，可以通过反射读取 1234567@Inherited //允许子类继承@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited {} 1234567@Documented //生成javadoc时会包含注解信息@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented {} JDK中自带注解123456@Override //一般在实现了接口的方法上标识，作用是告诉编译器该方法是接口的方法。该方法的确覆盖或实现了在超类型中声明的方法。@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {} 1234567@Deprecated //一般在接口中的方法上进行标识，作用是该方法过时了。@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})public @interface Deprecated {} 1234567@Suppvisewarnings //忽视警告，@SuppressWarnings(\"deprecation\")@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings { String[] value();} 常见第三方注解 @Autowired123456789@Autowired//@Service可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 //通过@Autowired的使用来消除set()、get()方法,使得接口可以被容器注入@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired { boolean required() default true;} @Resource12345678910111213141516171819@Resource//@Resource的作用相当于@Autowired//只不过@Autowired按byType自动注入，而@Resource默认按byName自动注入@Target({TYPE, FIELD, METHOD})@Retention(RUNTIME)public @interface Resource { String name() default \"\"; Class&lt;?&gt; type() default java.lang.Object.class;}//@Resource有两个属性是比较重要的，分是name和type。//Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。//所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。//如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。@Resource装配顺序//1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常//2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常//3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常//4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；// 如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Controller123456789101112@Controller//用于标注控制层组件@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller { @AliasFor( annotation = Component.class ) String value() default \"\";} @Service123456789101112@Service //@Service用于标注业务层组件@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service { @AliasFor( annotation = Component.class ) String value() default \"\";} @Repository123456789101112@Repository//用于标注数据访问组件@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository { @AliasFor( annotation = Component.class ) String value() default \"\";} @Component123456789@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component { String value() default \"\";} 使用注解的语法 例如：12345@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;, &lt;成员名2&gt;=&lt;成员值2&gt;, …)@Description(desc=\"I am little bird\", author=\"jermi\", age=1)public String bird(){ return \"bird\";} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"GROUP BY和HAVING的用法","date":"2019-11-05T04:00:00.000Z","path":"posts/f098441a.html","text":"前言 GROUP BY 是分组查询, 一般 GROUP BY 是和聚合函数配合使用。 group by 有一个原则,就是 满足SELECT子句中的列名必须为分组列或列函数。 列函数对于group by子句定义的每个组各返回一个结果。 HAVING 通常与GROUP BY子句一起使用 WHERE过滤行，HAVING过滤组 出现在同一sql的顺序：WHERE -&gt; GROUP BY -&gt; HAVING 使用三张数据表-学生表(student_id、name、age、sex)、课程表(course_id、name)、成绩表(student_id、course_id、score) 学生表(student_id、name、age、sex) 课程表(course_id、name) 成绩表(student_id、course_id、score) GROUP BY 查询所有同学的学号、选课数、总成绩123select student_id, count(course_id), sum(score)from scoregroup by student_id; 列函数对于group by子句定义的每个组各返回一个结果。如果用group by，那么你的select语句中选出的列要么是你group by里用到的列，要么就是带有sum min count等函数的列 查询所有同学的学号、姓名、选课数、总成绩1234select s.student_id, stu.name, count(s.course_id), sum(s.score)from score s, student stuwhere s.student_id = stu.student_idgroup by s.student_id; group by 里出现某个表的字段，select里面的列要么是该group by里面的列，要么是别的表的列或者带有函数的列 HAVING 查询平均成绩大于60分的同学的学号和平均成绩 1234select student_id, avg(score)from scoregroup by student_idhaving avg(score) &gt; 60 having必须要在group by之后，不然会报错。如果省略了group by语句，having子句就跟where语句一样 查询没有学全所有课的同学的学号、姓名 12345678select stu.student_id, stu.namefrom student stu, score swhere stu.student_id = s.student_idgroup by s.student_idhaving count(*) &lt;( select count(*) from course) 取出student_id为1的学生的成绩情况 1234select s.student_id, c.name, s.scorefrom score s, course cwhere s.course_id = c.course_idhaving s.student_id = 1 where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.zeffon.cn/tags/mysql/"}]},{"title":"vimium的使用","date":"2019-11-04T04:00:00.000Z","path":"posts/179a1564.html","text":"前言 vimium类似于vim的快捷键，是chrome浏览器的一款插件, 可以用键盘代替鼠标的操作, 提高我们的浏览速度和上网体验。 使用 Vimium作为Chrome的一个扩展工具，安装当然很简单。在Chrome应用店上安装即可Vimium 可以自定义快捷方式右击右上角扩展的图标 -&gt; 进入选项 -&gt; 在Custom key mappings新增下面快捷内容 -&gt; 点击下面save changes 1234567891011// Insert your preferred key mappings here.map w scrollUpmap s scrollDownmap a scrollLeftmap d scrollRightmap l scrollPageDownmap h scrollPageUpmap qq scrollToTopmap ee scrollToBottommap j goBackmap k goForward 官方的快捷方式说明 常用的快捷方式(默认) 页面的移动 按键 效果 r 刷新 f/F 跳转链接 h/j/k/l 左/下/上/右 u/d 上/下半页滚动 gg/G 回到顶部/底部 H/L 后退/前进 复制&amp;粘贴 按键 效果 yy 复制当前页面的url到剪切板 yt 重复当前标签 p/P 搜索剪贴板关键字 在当前/新标签 模式&amp;定位 按键 效果 i/v 编辑模式/可视模式 gi 定位到页面首个输入框 2gi 定位到页面第二个输入框 / 进入寻找模式 n/N 向下/上查找结果 书签 按键 效果 o/O 查找历史记录+书签 b/B 打开书签 在当前/新窗口 标签 按键 效果 t/T 创建/查看标签页 ^ 上一次标签切换 x/X 关闭/恢复标签 J,gT/K,gt 跳转标签页 g0/g$ 切换到首个标签/最后标签 gu/gU 跳转到当前url上一级/最高级 ge/gE 编辑url 在当前/新标签 ? 显示帮助 平时要是忘记了快捷方式,也可以在浏览器页面 ? 显示快捷键帮助 扩展ideavim Jetbrains系列软件直接在插件浏览器搜索安装即可，重启后在边栏tools上可以看到vim Emulator 由于ideavim有些快捷方式与IDEA原本快捷方式会冲突, 可以在以下位置进行设置。 12preferences -&gt; Editor -&gt; Vim Emulation(mac系统) Settings -&gt; Other Settings -&gt; Vim Emulation设置(win系统) 可以选择冲突的按键统一设置成IDE的快捷键。 vscode vim 直接在扩展搜索vim安装即可 使用系统剪贴板-&gt;设置true1在首选项 -&gt; 设置 -&gt; 配置搜索vim.useSystemClipboardsh -&gt; 设置true(打勾) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vim","slug":"vim","permalink":"https://www.zeffon.cn/tags/vim/"}]},{"title":"vim的基本入门","date":"2019-11-03T04:00:00.000Z","path":"posts/835116a6.html","text":"前言工善其事，必利其器。Linux系统中常见的编辑技巧，vim必不可少。Vim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。Vim的第一个版本由布莱姆·米勒在ADM-3A终端上开发的，于1991年发布。 使用本篇学习于慕课网DevOps24h讲师的优雅玩转Vim-课程 移动、跳转和缩进 光标移动 按键 效果 h/j/k/l 左/下/上/右 ^/0 移动到行首/包括缩进空格 $ 移动到行尾 单词和字符串移动 按键 效果 w/W 正向移动到下一个单词开头 b/B 反向移动 e/E 正向移动下一个单词行尾 ge 反向移动 跳转 按键 效果 Ctrl-f/F 下一页 Ctrl-b/B 上一页 Ctrl-d/u 向下/上翻半页 gg 跳转到首行 gg/G 跳转到指定行 {g} + Ctrl-g/G 跳转到最后一行 缩进 按键 效果 &gt;&gt; / :&gt; 右缩进 m,n&gt; / :m&gt;(n-m+1) m 到 n 行缩进 m&gt;n等价于命令:m,m+n-1&gt; m行开始共n行缩进一次 删除、复制和粘贴 对比 windowa Vim 不同处 cut delete 和剪切相同，而不是直接删除 copy yank 等同于复制由于c用于修改(change)被迫选了yank paste put 粘贴完全相同 基本操作 按键 效果 d = delete = cut 剪切 dd 剪切当前光标整行 y = yank ≈ copy 类似于复制 p/P = put ≈ paste 粘贴到光标后/光标前 u = undo 撤销之前操作 Ctrl-r = redo 重做/恢复之前操作 yw 复制当前光标单词 y2w 复制正向两个单词 yy 类似于 dd 复制当前光标整行 组合删除 按键 效果 x/X 删除光标下/前单个字符 dw(d=delete, w=word) 删除一单词(必须在词首) d{hjkl} 删除到左下上右一个操作前的字符 d$=D 删除光标到行尾的字符 d^ 删除光标到行首的字符 dd 删除当前整行 {n}dd 向下删除n行(包括当前行) 5dw 删除正向单词5次 3w 正向移动单词3次 D3w 正向删除3w动作 2d3w 正向删除3w动作2次 修改、查找和替换 插入 按键 效果 Shift+i/A 插入模式并移动到行首/行尾 a/i 光标后/前插入 {n}O/o 行前/行后插入n次 {n}+i 插入模式重复n次 转换 按键 效果 ~ 单个字符大小写转换 g ~ w 单词大小写转换 g ~ $ / g ~ ~ 行前/行后插入n次 gU/uw 单词转换成大/小写 查找 按键 效果 F/f{char} 反向/正向查找单个字符 t{char} 查找字符前一个字符 dt{char} / df{space} 删除光标到查找字符间字符 /{char} 命令行查找 替换 按键 效果 Shift + r/R 替换模式 r 单个字符替换 cw 修改单个单词 c$ / C 修改光标之后行内内容 s/going/rolling/g 当前行所有going替换成rolling %s/going/rolling/g %匹配所有范围 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"vim","slug":"vim","permalink":"https://www.zeffon.cn/tags/vim/"}]},{"title":"搭建GitLab私服","date":"2019-11-02T04:00:00.000Z","path":"posts/2e8979ff.html","text":"前言基于Docker部署GitLab环境搭建，搭建自己的git服务器。 由于GitLab运行的占用内存较大，所以建议服务器内存2G以上 运行搭建 下载镜像文件1$ docker pull beginor/gitlab-ce:11.0.1-ce.0 注意 如果下载速度慢的话，需要配置一下阿里云的镜像加速地址 1234567Docker 镜像加速地址$ vim /etc/docker/daemon.json{ \"registry-mirrors\": [\"https://fy707np5.mirror.aliyuncs.com\"]}$ systemctl daemon-reload # 令daemon.json生效$ systemctl restart docker # 重启Docker 创建GitLab 的配置(config) 、 日志(logs) 、数据(data) 放到容器之外， 便于日后升级， 因此请先准备这三个目录。 123$ mkdir -p /srv/gitlab/config$ mkdir -p /srv/gitlab/logs$ mkdir -p /srv/gitlab/data 运行GitLab容器（注意机器是否关了SELinux） 123456789docker run --detach \\--publish 8443:443 \\--publish 8090:80 \\--name gitlab \\--restart always \\--volume /srv/gitlab/config:/etc/gitlab \\--volume /srv/gitlab/logs:/var/log/gitlab \\--volume /srv/gitlab/data:/var/opt/gitlab \\gitlab/gitlab-ce:latest 如果机器没关SELinux(一般的服务器默认是关的，虚拟机可能没关) 123$ vi /etc/selinux/config将SELINUX=enforcing改为SELINUX=disabled 设置后需要重启机器才能生效 修改/srv/gitlab/config/gitlab.rb 123把external_url改成部署机器的域名或者IP地址$ vi /srv/gitlab/config/gitlab.rbexternal_url 'http://10.71.29.81' 修改/srv/gitlab/data/gitlab-rails/etc/gitlab.yml 123$ vi /srv/gitlab/data/gitlab-rails/etc/gitlab.yml找到关键字 * ## Web server settings * 将host的值改成映射的外部主机ip地址和端口，这里会显示在gitlab克隆地址 修改后需要停止docker容器，并且删除，后重启docker, 最后再运行GitLab容器 1234docker stop 容器iddocker rm 容器idsystemctl restart docker docker run … gitlab的web管理页面就可以正常访问http://10.71.29.81:8090 参考文献GitLab文档 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"git","slug":"git","permalink":"https://www.zeffon.cn/tags/git/"},{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"},{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"}]},{"title":"Docker搭建Maven私服","date":"2019-11-01T04:00:00.000Z","path":"posts/6a676863.html","text":"前言私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。Maven私服应用场景 ： 缓存企业级jar 微服务开发中，实现对微服务接口实现发布与调用。 正常在微服务开发中，不会直接引入到其他接口源码项目。引入接口jar包进行调用。 流程下载&amp;&amp;启动 Docker拉取一个nexus3的镜像1$ docker pull sonatype/nexus3 将容器内部/var/nexus-data挂载到主机/root/nexus-data目录1$ docker run -d -p 8081:8081 --name nexus -v /root/nexus-data:/var/nexus-data --restart=always sonatype/nexus3 关闭防火墙，根据服务器ip访问 http://ip:80811$ systemctl stop firewalld.service Maven 私服启动容器稍微比较慢，等待1分钟即可。 登陆使用默认账号密码 admin admin123 登陆时，发现登陆不了。这是更改这种admin123固定密码登陆方式。需要进入容器里面寻找密码。 查看进行的容器，并进入容器1234$ docker psCONTAINER ID IMAGE 9c9b18024931 sonatype/nexus3 $ docker exec -it 9c9b18024931 bash 查看密码(bash-4.4$前面的字符串即是密码)123bash-4.4$ cat /nexus-data/admin.password3rhu2s4g-34d5-34d5-fs9d-we2fh8242wh3bash-4.4$ #退出容器用 exit 命令 在登陆界面进行登陆，再根据提示重置密码即可 创建Maven私服仓库 创建私服仓库创建仓库，点击Create repository,然后选择maven2(hosted)然后输入仓库名称（test-release）。在version policy中选择这个仓库的类型，这里选择release,在Deployment policy中选择Allow redeploy（这个很重要）. 创建私服账号点击左侧菜单栏的Users菜单，然后点击Create local user.我这里创建了一个用户，账号密码都是：testUsertestUser-release 修改本地settings.xml 1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;testUser&lt;/id&gt; &lt;username&gt;testUser&lt;/username&gt; &lt;password&gt;testUser&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 创建一个Maven工程 注意 限定版本一定为RELEASE,因为上传的对应仓库的存储类型为RELEASE 123456789101112131415161718192021222324252627282930313233&lt;!--指定仓库地址 --&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;!--此名称要和.m2/settings.xml中设置的ID一致 --&gt; &lt;id&gt;testUser&lt;/id&gt; &lt;url&gt;http://192.168.162.22:8081/repository/testUser-release/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--发布代码Jar插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/plugin&gt; &lt;!--发布源码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 发布jar包到Maven私服 1$ mvn deploy 参考文献Nexus3 Docker document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"},{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"}]},{"title":"构建分布式配置中心阿波罗","date":"2019-10-31T04:00:00.000Z","path":"posts/e16afb9f.html","text":"前文分布式配置中心阿波罗是国内携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 使用搭建时需要Java环境和Mysql数据库 搭建分布式配置中心阿波罗 去往Github下载apollo 上传apollo-build-scripts-master配置文件到服务器中，然后解压配置文件 123$ unzip apollo-build-scripts-master.zip // 如果没有unzip命令的话，安装zip插件 $ yum -y install zip unzip 配置数据策略 12修改demo.sh中的数据库host、root、密码修改config_server_url、admin_server_url、portal_url的ip为本机ip（建议修改） 启动阿波罗 12$ ./demo.sh start$ systemctl stop firewalld.service 8070登陆界面—–默认账号密码 Apollo admin 服务客户端集成配置文件 将本地配置存入到阿波罗平台中。yml -&gt; prop 转换工具 引入Maven依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-core&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 创建 application.properties 12$ app.id=对应的应用id$ apollo.meta=http://Apollo运行ip:8080 项目启动开启阿波罗配置文件 1234添加注解 @EnableApolloConfig修改/opt/data/user/server.properties（Mac/Linux）或C:\\opt\\data\\server.properties（Windows）文件设置env为DEV：env=DEV 注意：不是所有的配置文件都会在阿波罗平台修改后，就会立马生效，因为没有采用监听刷新配置文件。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"}]},{"title":"Docker安装MQ队列","date":"2019-10-22T04:00:00.000Z","path":"posts/d25fdc55.html","text":"Docker安装Linux环境下使用docker快速安装各个MQ队列请观看之前的博客内容Docker安装教程 应用安装安装 RabbitMQ 安装官方的镜像 1$ docker run -d --name my-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3.7.3-management 后台admin界面(账号密码默认是guest) 1http://127.0.0.1:15672 安装 ActiveMQ 搜索镜像 12345678$ docker search activemqNAME DESCRIPTION STARS OFFICIAL AUTOMATEDwebcenter/activemq ActiveMQ 5.14.3 with OpenJDK-jre-8-headless … 170 [OK]rmohr/activemq Various versions of ActiveMQ neatly packet i… 90 [OK]vromero/activemq-artemis ActiveMQ Artemis image (Debian and Alpine ba… 18 [OK]cloudesire/activemq Latest activemq 4 [OK]aterreno/activemq-dockerfile 3 [OK]andreptb/activemq Debian Jessie based image with ActiveMQ inst… 3 [OK] 安装webcenter/activemq中最新版本 1234$ docker run -d --name myactivemq \\-p 61616:61616 \\-p 8161:8161 \\webcenter/activemq 后台admin界面(账号密码默认是admin) 1http://127.0.0.1:8161/admin/topics.jsp 安装 RocketMQ 搜索RocketMQ的镜像,并没有官方的镜像 123456789101112$ docker search rocketmqNAME DESCRIPTION STARS OFFICIAL AUTOMATEDstyletang/rocketmq-console-ng rocketmq-console-ng 18foxiswho/rocketmq rocketmq 14rocketmqinc/rocketmq Image repository for Apache RocketMQ 13laoyumi/rocketmq 10 [OK]xlxwhy/rocketmq alibaba's rocketmq 4huanwei/rocketmq-broker 22019liurui/rocketmq-broker RocketMQ broker image for RocketMQ-Operator 12019liurui/rocketmq-namesrv RocketMQ name service image for RocketMQ-Ope… 1slpcat/rocketmq-console-ng 0coder4/rocketmq rocketmq 0 [OK] 安装 foxiswho/rocketmq 镜像 123$ curl https://registry.hub.docker.com/v1/repositories/foxiswho/rocketmq/tags\\| tr -d '[\\[\\]\" ]' | tr '}' '\\n'\\| awk -F: -v image='foxiswho/rocketmq' '{if(NR!=NF &amp;&amp; $3 != \"\"){printf(\"%s:%s\\n\",image,$3)}}' 启动nameserver 1$ docker run -d -p 9876:9876 --name rmqserver foxiswho/rocketmq:server-4.5.1 启动broker 12345678$ docker run -d -p 10911:10911 -p 10909:10909\\--name rmqbroker --link rmqserver:namesrv\\-e \"NAMESRV_ADDR=namesrv:9876\" -e \"JAVA_OPTS=-Duser.home=/opt\"\\-e \"JAVA_OPT_EXT=-server -Xms128m -Xmx128m\"\\foxiswho/rocketmq:broker-4.5.1# Broker容器中默认的配置文件的路径为：/etc/rocketmq/broker.conf 安装rocketmq console工具, 通过上面查询的方式找到需要启动的版本，启动方式如下： 1234$ docker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\\ -e \"JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\\ -Dcom.rocketmq.sendMessageWithVIPChannel=false\"\\ -t styletang/rocketmq-console-ng 命令检查一下启动情况, 后台admin界面访问http://127.0.0.1:8180 1$ docker ps|grep rocketmq document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"}]},{"title":"Java API自动生成文档","date":"2019-10-17T04:00:00.000Z","path":"posts/45b37915.html","text":"前文Java API文档自动生成有swagger2和spring restdocs两种受欢迎的工具。 Swagger2的使用介绍swagger2通过配置，会提供了一个url：http://localhost:8080/v2/api-docs，返回了所有api的信息。读取这个url，将结果存储到swagger.json。利用swagger2markup-maven-plugin插件读取swagger.json，生成一系列adoc文件。最后利用asciidoctor-maven-plugin插件将index.adoc文件转成html或pdf。 使用过程 引进依赖包 123456789101112&lt;!-- swagger工具包 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;${swagger.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;${swagger.version}&lt;/version&gt;&lt;/dependency&gt; 在配置application.yml中，用于SwaggerConfig读取。这样可以控制是否开启(线上环境关闭) 12swagger2: show: true 配置Swagger2（注意扫描的包的路径是否正确，否则会显示不了数据） 123456789101112131415161718192021222324@Configuration@EnableSwagger2public class SwaggerConfig { @Value(\"${swagger2.show}\") private boolean swagger2Show; @Bean public Docket swaggerSpringMvcPlugin() { return new Docket(DocumentationType.SWAGGER_2) .enable(swagger2Show) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.zeffon.esave\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"swagger-bootstrap-ui RESTful APIs\") .version(\"1.0\") .build(); }} 在API类和方法上加注解 12345678910111213141516171819@Api(value = \"解锁日志\")@RestController@RequestMapping(\"/log\")public class UnlockLogAPI { private final UnlockLogService unlockLogService; @Autowired public UnlockLogAPI(UnlockLogService unlockLogService) { this.unlockLogService = unlockLogService; } @GetMapping(\"/listUnlockLog\") @ApiOperation(value = \"获取用户全部解锁记录\", notes = \"全部解锁记录\", tags = \"日志\") public ResultVOUtil listUnlockLog() { List&lt;UnlockLogVO&gt; unlockLog = unlockLogService.listUnlockLog(); return ResultVOUtil.success(unlockLog); }} 实体类和其属性加注解 123456@Data@ApiModel(value = \"开锁日志\", description = \"用户每次开锁的记录\")public class UnlockLog extends Base { @ApiModelProperty(example = \"1\", notes = \"用户id\") private Long uid;} 运行程序，在浏览器中打开http://127.0.0.1:8081/esave/swagger-ui.html#/ 注解说明 API 作用范围 使用位置 @ApiModel 描述返回对象的意义 用在返回对象类上 @ApiModelProperty 对象属性 用在出入参数对象的字段上 @Api 协议集描述 用于 controller 类上 @ApiOperation 协议描述 用在 controller 的方法上 @ApiResponses Response集 用在 controller 的方法上 @ApiResponse Response 用在 @ApiResponses 里边 @ApiImplicitParams 非对象参数集 用在 controller 的方法上 @ApiImplicitParam 非对象参数描述 用在 @ApiImplicitParams 的方法里边 Spring REST Docs介绍 Spring REST Docs的目标替代SpringFox Swagger，帮助自动化生成RESTful服务的文档。 使用Asciidoctor编写的手写文档；Spring REST Docs为RESTful服务生成准确且可读的文档。 将手写文档与使用Spring测试生成的文档片段相结合。 不受Swagger等工具生成的文档的限制。 它可以生成准确，简洁和结构良好的API文档。 Spring REST Docs支持测试驱动Test Driven。 Spring REST Docs支持Spring MVC Test框架，Spring WebFlux的WebTestClient或REST Assured 3测试驱动。 Spring Boot 提供了注解@AutoConfigureRestDocs简化文档开发。 使用过程（未完待续） 引进依赖包123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 注解说明总结 Swagger2的定位是和应用一起启动的在线文档，文档的浏览者可以很简单的填写表单并发起一个真实的请求，而 Spring REST Docs 更倾向于导出一份离线文档作为展示，并配合 curl、httpie 这种工具请求真实部署的服务。 Swagger2最大的特点是使用简单，只需要在源码中增加一些描述性的注解即可完成整份文档，而使用 Spring REST Docs 的前提条件是需要在项目中对API进行单元测试。除了依赖，还需要严格的编写Test测试代码，保证测试代码通过。但是Spring REST Docs生成的文档比较符合于测试团队。 文献参考 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"}]},{"title":"nvm的使用","date":"2019-10-16T04:00:00.000Z","path":"posts/a5fc782.html","text":"前文nvm是node版本管理工具，用它可以方便的在机器上安装并维护多个Node的版本 使用Mac安装nvm安装前卸载掉已安装的Node和已安装的全局模块 检查是否安装node。 1$ node -v 若是版本信息返回，则进行删除 123456$ sudo npm uninstall npm -g$ sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*$ sudo rm -rf /usr/local/include/node /Users/$USER/.npm$ sudo rm /usr/local/bin/node$ sudo rm /usr/local/share/man/man1/node.1$ sudo rm /usr/local/lib/dtrace/node.d 验证是否卸载完成 12node -vnpm -v 使用curl进行安装nvm 1$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 配置环境变量 12export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" 完成以后检测是否安装成功 12$ nvm$ node version manger # 安装成功 执行 nvm, 如果提示 -bash: nvm: command not found, 需要手动配置变量 12345# 新建&nbsp;~/.bash_profile&nbsp;文件$ vi ~/.bash_profileexport NVM_DIR=\"${XDG_CONFIG_HOME/:-$HOME/.}nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm$&nbsp;source&nbsp;~/.nvm/nvm.sh # 使bash_profile生效 Win安装nvm github官网寻找下载包 程序安装过程中，在 Set Node.js Symlink 这一步目录设置，是待会 nvm use 存放你的 nodejs 程序的目录 [C:\\DevTools\\nodejs]。 Mac卸载nvm nvm卸载 1$ sudo rm -rf `$NVM_DIR` 执行完重启程序，输入 nvm 测试是否成功 1$ nvm 还需要到以下文件中删除干净NVM_DIR相关的 (如果有)~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc nvm常见命令1234567nvm version 查看当前的版本nvm install 安装最新版本nvmnvm install &lt;version&gt; 安装相应版本nvm use &lt;version&gt; 切换使用指定的版本nodenvm ls 列出所有版本nvm current显示当前版本nvm uninstall &lt;version&gt; 卸载制定的版本 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linux","slug":"linux","permalink":"https://www.zeffon.cn/tags/linux/"}]},{"title":"Java常见的模型转换方法","date":"2019-10-15T04:00:00.000Z","path":"posts/3884269f.html","text":"前文在进行不同领域对象转换时,原对象和目标对象相同属性的类型不一样,所以对象转换时一些需要考虑的问题。我在进行不同领域对象转换，一直都是用BeanUtils.copyProperties()搭配Set()使用的。听了张老师讲解之后，才知道方法如此之多。 转化方法我们的原对象OrderDTO的内容如下： 123456789101112131415161718192021222324252627282930{ \"orderDate\":1570558718699, \"orderId\":201909090001, \"orderStatus\":\"CREATED\", \"orderedProducts\":[ { \"price\":799.990000000000009094947017729282379150390625, \"productId\":1, \"productName\":\"吉他\", \"quantity\":1 }, { \"price\":30, \"productId\":2, \"productName\":\"变调夹\", \"quantity\":1 } ], \"paymentType\":\"CASH\", \"shopInfo\":{ \"shopId\":20000101, \"shopName\":\"慕课商铺\" }, \"totalMoney\":829.990000000000009094947017729282379150390625, \"userInfo\":{ \"userId\":20100001, \"userLevel\":2147483647, \"userName\":\"张小喜\" }} 期望转换后得到的目标对象OrderVO如下： 123456789101112131415161718{ \"orderDate\":\"2019-10-09 15:49:24.619\", \"orderStatus\":\"CREATED\", \"orderedProducts\":[ { \"productName\":\"吉他\", \"quantity\":1 }, { \"productName\":\"变调夹\", \"quantity\":1 } ], \"paymentType\":\"CASH\", \"shopName\":\"慕课商铺\", \"totalMoney\":\"829.99\", \"userName\":\"张小喜\"} 第1种：Get/Set操作。Get/Set直接对对象优点：直观、简单、处理速度快；缺点:属性过多时，比较浪费表情，而且代码不简洁 第2种：FastJson利用序列化和反序列化，这里我们采用先使用FastJson的toJSONString的方法将原对象序列化为字符串，再使用parseObject方法将字符串反序列化为目标对象。缺点：属性转化后不符合预期的，属性名也不一致问题 使用方式： 12// JSON.toJSONString将对象序列化成字符串，JSON.parseObject将字符串反序列化为OderVO对象orderVO = JSON.parseObject(JSON.toJSONString(orderDTO), OrderVO.class); 结果： 123456789101112131415161718// 目标对象{ \"orderDate\":\"1570558718699\", \"orderId\":201909090001, \"orderStatus\":\"CREATED\", \"orderedProducts\":[ { \"productName\":\"吉他\", \"quantity\":1 }, { \"productName\":\"变调夹\", \"quantity\":1 } ], \"paymentType\":\"CASH\", \"totalMoney\":\"829.990000000000009094947017729282379150390625\"} 可以看到 日期不符合我们的要求 金额也有问题 最严重的是，当属性名不一样时，不复制 第3种：Apache工具包PropertyUtils工具类缺点：属性类型不一样会报错，不能部分属性复制，得到的目标对象部分属性成功、部分失败 使用方式： 1PropertyUtils.copyProperties(orderVO, orderDTO); 转换过程中报错 1java.lang.IllegalArgumentException: Cannot invoke com.imooc.demo.OrderVO.setTotalMoney on bean class 'class com.imooc.demo.OrderVO' - argument type mismatch - had objects of type \"java.math.BigDecimal\" but expected signature \"java.lang.String\" 结果： 1234// 目标对象{ \"orderId\":201909090001} 结论： 属性类型不一样时报错 不能部分属性复制 得到的目标对象部分属性成功(这点很要命，部分成功，部分失败！) 第4种：Apache工具包BeanUtils工具类缺点：属性转化后不符合预期的，属性名也不一致问题 使用方式： 1BeanUtils.copyProperties(orderVO, orderDTO); 结果： 12345678910111213141516171819202122// 目标对象{ \"orderDate\":\"Wed Oct 09 02:36:25 CST 2019\", \"orderId\":201909090001, \"orderStatus\":\"CREATED\", \"orderedProducts\":[ { \"price\":799.990000000000009094947017729282379150390625, \"productId\":1, \"productName\":\"吉他\", \"quantity\":1 }, { \"price\":30, \"productId\":2, \"productName\":\"变调夹\", \"quantity\":1 } ], \"paymentType\":\"CASH\", \"totalMoney\":\"829.990000000000009094947017729282379150390625\"} 结论： 日期不符合要求 属性名不一样时不复制 目标对象中的商品集合变成了DTO的对象，这是因为List的泛型被擦除了，而且是浅拷贝，所以造成这种现象。 第5种：Spring封装BeanUtils工具类缺点：会出现属性丢失 使用方式： 12/** 对象属性转换，忽略orderedProducts字段 */BeanUtils.copyProperties(orderDTO, orderVO, \"orderedProducts\"); 结果： 1234/** 目标对象 */{ \"orderId\":201909090001} 结论： 可以忽略部分属性 属性类型不同，不能转换 属性名称不同，不能转换 apache的BeanUtils和spring的BeanUtils中拷贝方法的原理都是先用jdk中 java.beans.Introspector类的getBeanInfo()方法获取对象的属性信息及属性get/set方法，接着使用反射（Method的invoke(Object obj, Object... args)）方法进行赋值。 第6种：BeanCopiercglib工具包的BeanCopier采用了不同的方法：它不是利用反射对属性进行赋值，而是直接使用ASM的MethodVisitor直接编写各属性的get/set方法生成class文件，然后进行执行。 优点：字节码技术，速度快，自定义地处理的属性，其他未处理的属性就不行，提供自己自定义转换逻辑的方式缺点：转换逻辑自己写，比较复杂，繁琐；属性名称相同，类型不同，不会拷贝（原始类型和包装类型也被视为类型不同） 使用方式： 123456789101112131415// 构造转换器对象，最后的参数表示是否需要自定义转换器BeanCopier beanCopier = BeanCopier.create(orderDTO.getClass(), orderVO.getClass(), true);// 转换对象，自定义转换器处理特殊字段beanCopier.copy(orderDTO, orderVO, (value, target, context) -&gt; { // 原始数据value是Date类型，目标类型target是String if (value instanceof Date) { if (\"String\".equals(target.getSimpleName())) { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); return sdf.format(value); } } // 未匹配上的字段，原值返回 return value;}); 报错 1java.lang.ClassCastException: com.imooc.demo.OrderStatus cannot be cast to java.lang.String 结果： 12345// 目标对象{ \"orderDate\":\"2019-10-09 03:07:13.768\", \"orderId\":201909090001} 结论： 字节码技术，速度快 提供自己自定义转换逻辑的方式 转换逻辑自己写，比较复杂，繁琐 属性名称相同，类型不同，不会拷贝（原始类型和包装类型也被视为类型不同） 第7种：Dozer框架使用以上类库虽然可以不用手动编写get/set方法，但是他们都不能对不同名称的对象属性进行映射。在定制化的属性映射方面做得比较好的有Dozer，Dozer支持简单属性映射、复杂类型映射、双向映射、隐式映射以及递归映射。可使用xml或者注解进行映射的配置，支持自动类型转换，使用方便。但Dozer底层是使用reflect包下Field类的set(Object obj, Object value)方法进行属性赋值，执行速度上不是那么理想。 使用方式： 12345678// 创建转换器对象，强烈建议创建全局唯一的，避免不必要的开销DozerBeanMapper mapper = new DozerBeanMapper();// 加载映射文件mapper.addMapping(TransferTest.class.getResourceAsStream(\"/mapping.xml\"));// 转换orderVO = mapper.map(orderDTO, OrderVO.class); 结果： 12345678910111213141516171819// 目标对象{ \"orderDate\":\"2019-10-09 15:49:24.619\", \"orderStatus\":\"CREATED\", \"orderedProducts\":[ { \"productName\":\"吉他\", \"quantity\":1 }, { \"productName\":\"变调夹\", \"quantity\":1 } ], \"paymentType\":\"CASH\", \"shopName\":\"慕课商铺\", \"totalMoney\":\"829.99\", \"userName\":\"张小喜\"} 配置的字段映射文件： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;mappings xmlns=\"http://dozer.sourceforge.net\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://dozer.sourceforge.net http://dozer.sourceforge.net/schema/beanmapping.xsd\"&gt; &lt;!-- 一组类映射关系 --&gt; &lt;mapping&gt; &lt;!-- 类A和类B --&gt; &lt;class-a&gt;com.imooc.demo.OrderDTO&lt;/class-a&gt; &lt;class-b&gt;com.imooc.demo.OrderVO&lt;/class-b&gt; &lt;!-- 一组需要映射的特殊属性 --&gt; &lt;field&gt; &lt;a&gt;shopInfo.shopName&lt;/a&gt; &lt;b&gt;shopName&lt;/b&gt; &lt;/field&gt; &lt;!-- 将嵌套对象中的某个属性值映射到目标对象的指定属性上 --&gt; &lt;field&gt; &lt;a&gt;userInfo.userName&lt;/a&gt; &lt;b&gt;userName&lt;/b&gt; &lt;/field&gt; &lt;!-- 将Date对象映射成指定格式的日期字符串 --&gt; &lt;field&gt; &lt;a&gt;orderDate&lt;/a&gt; &lt;b date-format=\"yyyy-MM-dd HH:mm:ss.SSS\"&gt;orderDate&lt;/b&gt; &lt;/field&gt; &lt;!-- 自定义属性转化器 --&gt; &lt;field custom-converter=\"com.imooc.demo.DozerCustomConverter\"&gt; &lt;a&gt;totalMoney&lt;/a&gt; &lt;b&gt;totalMoney&lt;/b&gt; &lt;/field&gt; &lt;!-- 忽略指定属性 --&gt; &lt;field-exclude&gt; &lt;a&gt;orderId&lt;/a&gt; &lt;b&gt;orderId&lt;/b&gt; &lt;/field-exclude&gt; &lt;/mapping&gt;&lt;/mappings&gt; 自定义转换器： 1234567891011121314public class DozerCustomConverter implements CustomConverter { @Override public Object convert(Object destination, Object source, Class&lt;?&gt; destClass, Class&lt;?&gt; sourceClass) { // 如果原始属性为BigDecimal类型 if (source instanceof BigDecimal) { // 目标属性为String类型 if (\"String\".equals(destClass.getSimpleName())) { return String.valueOf(((BigDecimal) source).doubleValue()); } } return destination; }} 结论： 支持多种数据类型自动转换（双向的） 支持不同属性名之间转换 支持三种映射配置方式（注解方式，API方式，XML方式） 支持配置忽略部分属性 支持自定义属性转换器 嵌套对象深拷贝 第八种：MapStruct框架：基于JSR269的Java注解处理器，通过注解配置映射关系，在编译时自动生成接口实现类。类似于Lombok的原理一样。 第九种：Orika框架：支持在代码中注册字段映射，通过javassist类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件。 第十种：ModelMapper框架：基于反射原理进行赋值或者直接对成员变量赋值。 总结 介绍的这些转换方法中，在性能上基本遵循：手动赋值 &gt; cglib &gt; 反射 &gt; Dozer &gt; 序列化。 在实际项目中，需要综合使用上述方法进行模型转换。比如较低层的DO，因为涉及到的嵌套对象少，改动也少，所以可以使用BeanUtils直接转。如果是速度、稳定优先的系统，还是简单粗暴地使用Set、Get实现吧。 文献参考 本篇学习于慕课网-张小喜老师手记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://www.zeffon.cn/tags/java/"}]},{"title":"Mysql并发访问事务问题","date":"2019-10-13T04:00:00.000Z","path":"posts/90824423.html","text":"前言Mysql事务并发访问导致的问题–更新丢失、脏读、不可重复读、幻读。Mysql数据库事务的四大特性–原子性、一致性、隔离性、持久性。而锁是数据库中的一个非常重要的概念，它主要用于多用户环境下保证数据库完整性和一致性。如果在多用户并发情况下，他们的事务同时对相同的数据进行操作，是会导致更新丢失、脏读、不可重复读、幻读的问题的。 更新丢失 Mysql所有事务隔离级别在数据库层面上均可避免更新丢失问题 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。 每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。 如果在A事务完成之后，B事务才能进行更改，则可以避免该问题。 更新丢失Demo 取款事务 存款事务 开始事务 开始事务 查询转账余额为100元 查询转账余额为100元 存入20元，余额变为120元 提交事务 取出10元，余额改为90元 回滚事务，余额恢复为100元 更新丢失 脏读 READ-COMMITTED事务隔离级别以上可避免–脏读问题 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 如果在B事务确定最终更改前，A事务或者其它事务都不能读取更改的文档，则可以避免该问题。 脏读Demo 数据库默认的隔离级别是REPEATABLE-READ。为了演示脏读效果，需要先将数据库隔离级别设置成READ-UNCOMMITTED。 12select @@tx_isolation;set session transaction isolation level read uncommitted; A事务 B事务 开始事务 开始事务 1账户余额1000元，转出100元 查询1账户剩900元 查询1账户剩900元 没有进行事务提交，而是事务回滚，余额恢复1000元 不知道A事务进行回滚，对1账户存入200元 提交事务 再次查询1账户余额1100 不可重复读 REPEATABLE_READ事务隔离级别以上可避免–不可重复读问题 不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。 如果在B事务确定最终更改前，A事务或者其它事务都不能读取更改的文档，则可以避免该问题。 不可重复读Demo A事务 B事务 开始事务 开始事务 查询1账户余额1300元 对1账户存入300元 查询1账户剩1600元 进行事务提交 查询1账户余额1600元 数据库默认的隔离级别是REPEATABLE-READ。若将数据库隔离级别设置成REPEATABLE_READ，则A事务第二次查询余额还是1300元，不会是1600元。12select @@tx_isolation;set session transaction isolation level repeatable read; 幻读 SERIALIZABLE事务隔离级别可避免–幻读问题 幻读与不可重复读看似类似，不可重复读侧重于对同一数据的修改，幻读侧重于新增或删除。 幻觉读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 幻读Demo A事务 B事务 开始事务 开始事务 查询全部账号余额，当前有3个账号 新增4账号及其余额 进行事务提交 更新所有的账户余额 出现有四个账号幻读的现象 数据库默认的隔离级别是REPEATABLE-READ。若将数据库隔离级别设置成SERIALIZABLE，则B事务新增账号4需要等待A事务操作完才能进行。 12select @@tx_isolation;set session transaction isolation level serializable; 总结事务并发访问引起的问题以及如何避免 事务隔离级别 更新丢失 脏读 不可重复读 幻读 未提交读 避免 发生 发生 发生 已提交读 避免 避免 发生 发生 可重复读 避免 避免 避免 发生 串行化 避免 避免 避免 避免 事务级别越高安全性越高，串行化执行越严重，这样就可以降低数据库的并发度，但性能要求也会越高。 文献参考sql语句对数据库表进行加锁和解锁 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.zeffon.cn/tags/mysql/"}]},{"title":"修改Git已提交的用户名和邮箱","date":"2019-10-12T04:00:00.000Z","path":"posts/e7e42196.html","text":"前言修改本地全局Git的提交用户名和邮箱和推送过的git用户名和邮箱 正文本地全局Git的提交用户名和邮箱12$ git config –global user.name “Your Name”$ git config –global user.email “Your Email” 注意： 这种方法只对之后的Commit有效，之前提交过记录就改不了了。 强行修改推送过的git用户名和邮箱 打开本地终端 打开需要修改的项目的根目录 复制下面的脚本，可以直接复制到终端命令行里或新建 Shell 脚本，并修改 oldEmail, newName, newEmail 三个变量为你自己的 12345678910111213141516171819#!/bin/bashgit filter-branch --env-filter 'oldEmail=\"Your Old Email\"newName=\"Your New Name\"newEmail=\"Your New Email\"if [ \"$GIT_COMMITTER_EMAIL\" = \"$oldEmail\" ]; then export GIT_COMMITTER_NAME=\"$newName\" export GIT_COMMITTER_EMAIL=\"$newEmail\"fiif [ \"$GIT_AUTHOR_EMAIL\" = \"$oldEmail\" ]; then export GIT_AUTHOR_NAME=\"$newName\" export GIT_AUTHOR_EMAIL=\"$newEmail\"fi' --tag-name-filter cat -- --branches --tags 执行脚本，看到一堆 rewritten 的时候就说明写入完成了 git log 查看新的 Commit 信息是否正确 再次推送时会失败，只能强制推送了 1$ git push -u origin master -f 删除临时文件 12$ cd ..$ rm -rf repo.git document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"git","slug":"git","permalink":"https://www.zeffon.cn/tags/git/"}]},{"title":"初识spu和sku","date":"2019-10-06T04:00:00.000Z","path":"posts/f34d9f58.html","text":"基本概念SPU英文全称Standard Product Unit(标准产品单位)、SKU英文全称stock keeping unit(库存量单位)。 商品SPU SPU 是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。 我们在浏览mac官网时，上栏有MacBook Air、MacBook Pro、iMac…等等。其中MacBook Air是一个SPU，MacBook Pro也是一个SPU，iMac也是一个SPU。简单的说：MacBook Air就是一个SPU，这与颜色和内存大小都无关。实际上指的就是MacBook Air这台笔记本。 商品SKU SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位。 当你点进MacBook Air购买时,页面有两种内存大小不同的款式，并且不同的款式间有三种颜色选择。如果你选择 128G 银色 的MacBook Air。这时候你选择了具体的内存大小和颜色的MacBook Air就是一个SKU。不同的内存大小MacBook Air的价格是肯定是不同，而且不同的颜色和内存大小的库存也是不同的。可能256G 银色这款比较受欢迎，所以256G 银色 的MacBook Air库存会比较少。 SPU和SKU间关系 结合前面所举的列子来看，SPU与SKU两者的关系似乎就是类目下包含SPU，SPU包含SKU。 SPU是一个抽象概念的商品（MacBook Air），而SKU是一个更为具体的商品（128G 银色 的MacBook Air）。这里不难看出商品SKU从属于商品SPU。 由于SKU从属于SPU，故两者的功能有所差别： SPU通常是用来定位某件商品，而SKU通常是用来定价和管理库存。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Redis的使用","date":"2019-09-12T03:53:54.000Z","path":"posts/2ba83191.html","text":"前言Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。 正文安装包安装在Redis官网，下载Redis安装包，当前最新版本5.0.5。安装Redis需要先提前安装好gcc相关的包。如果不需要太高的版本，4.x.x+版本也可以了。这里就使用4.0.8演示。 验证linux中是否已安装redis (下面这种情况是已安装的) 1234$ whereis redis-cliredis-cli: /usr/local/bin/redis-cli$ whereis redis-serverredis-server: /usr/local/bin/redis-server 安装gcc 1$ yum install -y open-ssl-devel gcc glibc gcc-c* 安装包下载 1$ wget http://download.redis.io/releases/redis-4.0.8.tar.gz 解压安装包 1$ tar xzf redis-4.0.8.tar.gz 拷贝的local目录下并进入该目录 12$ sudo cp -rf redis-4.0.8 /usr/local/ $ cd /usr/local/redis-4.0.8 编译安装 12$ make $ make install 添加redis到命令到全局变量，方便在任何目录执行； 12$ vi /etc/profileexport PATH=\"$PATH:/usr/local/redis-4.0.8/bin\" 运行使用 服务端启动redis服务器，命令如下，指定配置文件：1$ redis-server /usr/local/redis-4.0.8/src/redis.conf 客户端启动12345$ ./redis-cli -h 127.0.0.1 -p 6379 -n 2 -a test123-h 指定远程登陆ip-p 指定远程redis访问端口-n 指定库b编号-a 指定密码 关闭redis服务1234$ ps -ef | grep redisroot 29185 1 0 09:58 ? 00:00:00 redis-server 0.0.0.0:6379root 29190 29159 0 09:58 pts/0 00:00:00 grep --color=auto redis$ kill -9 29185 redis配置参数12345678910111213141516171. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no2. 指定Redis监听端口，默认端口为6379port 63793.当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 3004. 设置Redis连接密码，默认关闭requirepass password5. 在logfile中配置日志文件路径。logfile \"/var/log/redis.log\"6. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库iddatabases 1 解决无法连接问题 先修改redis.conf的配置内容设置禁用模式为no和设置密码1234a&gt;protected-mode&nbsp;no b&gt;requirepass passwordc&gt;注释bind:127.0.0.1(或者修改为bind 0.0.0.0 -&gt;&gt;代表允许任意ip的请求)d&gt;重新启动：./src/redis-server redis.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"redis","slug":"redis","permalink":"https://www.zeffon.cn/tags/redis/"}]},{"title":"Docker部署Java项目","date":"2019-09-11T04:23:10.000Z","path":"posts/70ec72e4.html","text":"前言介绍使用Docker通过Dockerfile文件定制SpringBoot项目的Jar成镜像，并推送到阿里私有的镜像仓库。 介绍Docker介绍Docker是DotCloud开源的、可以将任何应用包装在Linux container中运行的工具。基于Docker的沙箱环境可以实现轻型隔离，多个容器间不会相互影响；Docker可以自动化打包和部署任何应用，方便地创建一个轻量级私有PaaS云，也可以用于搭建开发测试环境以及部署可扩展的web应用等。 阿里容器服务容器服务提供高性能可伸缩的容器应用管理服务，支持用 Docker 和 Kubernetes 进行容器化应用的生命周期管理，提供多种应用发布方式和持续交付能力并支持微服务架构。容器服务简化了容器管理集群的搭建工作，整合了阿里云虚拟化、存储、网络和安全能力，打造云端最佳容器运行环境。 项目打包&amp;&amp;构建镜像Java应用打包 将Java应用进行打包(需要进入项目的根目录) 1$ mvn clean package -Dmaven.test.skip=true . 命令解释: clean清除之前的包、-Dmaven.test.skip=true 跳过测试用例、. 表示当前目录下 创建Dockerfile文件定制镜像(Docker运行的脚本)，并编写脚本内容 1$ vi Dockerfile # 在项目根目录下 12345678FROM hub.c.163.com/library/java:8-alpineADD target/*.jar app.jarEXPOSE 8085ENTRYPOINT [\"java\", \"-jar\", \"/app.jar\"]# FROM 从hub.c.163.com国内仓库拉取java包，# ADD 添加相对路径下的某个jar包，并且重命名为app.jar# EXPOSE 输出端口为8085# ENTRYPOINT 运行命令为 java -jar app.jar 镜像构建与运行 构建Docker镜像 12345$ docker build -t xiaozhi/doorplate . # 注意最后需要加上 . # 构建镜像# REPOSITORY:TAG 给镜像指定一个名称或版本(不指定时默认为latest)# 所以这里的镜像名称为doorplate# . 表示当前目录 查看刚刚构建Docker镜像 1234$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZExiaozhi/doorplate latest 3d7074872868 33 seconds ago 186MBhub.c.163.com/library/java 8-alpine d991edd81416 2 years ago 145MB 运行Docker镜像 123$ docker run -d -p 8899:8085 xiaozhi/doorplate# docker run -d -p 主机端口:容器端口 容器的名称# 8899是本机访问的端口，8085是Docker内部的端口 -d 后台运行 查看正在运行的Docker镜像 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES843bc974634f xiaozhi/doorplate \"java -jar /doorplat…\" 3 seconds ago Up 2 seconds 0.0.0.0:8085-&gt;8085/tcp nostalgic_thompson 阿里镜像推送这里将本地的镜像推送到阿里云的私有库。所以需要先在阿里云的镜像仓库中注册账号。 阿里容器镜像服务 登陆阿里云账号，搜索容器镜像服务，没开通服务的话需要开通服务。 左侧默认实例下点进命名空间，在右上角创建命名空间 点进镜像仓库，选择命名空间进行创建镜像仓库，代码源选择本地仓库。 点进生成镜像的管理，里面有操作指南，根据提示推送本地镜像即可。 本地镜像推送 注意 推送的镜像名称需要与阿里私有库上的命名的镜像名称一致。 先登录阿里云Docker Registry(这里的登陆密码是镜像服务的密码，不是阿里云账号密码) 1$ docker login --username=1355564603@qq.com registry.cn-shenzhen.aliyuncs.com 推送前重新打包一下 1$ mvn clean package -Dmaven.test.skip=true . 构建一个推送阿里云的镜像 1$ docker build -t registry.cn-shenzhen.aliyuncs.com/zeffon/doorplate . 镜像推送到Registry 1$ docker push registry.cn-shenzhen.aliyuncs.com/zeffon/doorplate 简化繁琐操作，将上面三条命令写成脚本 12345$ vi Build.sh # 在项目根目录下 #!/usr/bin/env bashmvn clean package -Dmaven.test.skip=true -U # 这里使用 -U 强制更新docker build -t registry.cn-shenzhen.aliyuncs.com/zeffon/doorplate .docker push registry.cn-shenzhen.aliyuncs.com/zeffon/doorplate document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"springBoot","slug":"springBoot","permalink":"https://www.zeffon.cn/tags/springBoot/"}]},{"title":"Linux搭建Docker环境","date":"2019-09-10T11:23:02.000Z","path":"posts/5ac7620d.html","text":"前言Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 前置条件版本问题和卸载旧版本64-bit 系统 kernel 3.10+ 检查内核版本，返回的值大于3.10即可。12$ uname -r3.10.0-693.el7.x86_64 # 64-bit 系统 kernel 3.10+ 使用 sudo 或 root 权限的用户登入终端。 卸载旧版本(如果安装过旧版本的话)1234$ yum remove docker \\ docker-common \\ docker-selinux \\ docker-engine 安装安装包和其他驱动依赖 安装需要的软件包驱动依赖123$ yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 设置yum源123$ yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 1.安装docker 第一种: 直接安装最新本1$ yum install -y docker-ce 第二种: 安装指定版本查询版本列表12345$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:19.03.1-3.el7 docker-ce-stabledocker-ce.x86_64 18.03.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 18.03.0.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.12.1.ce-1.el7.centos docker-ce-stable 指定版本安装(这里的例子是安装上面列表中的第一个)1$ yum install -y docker-ce-3:19.03.1 Docker的使用启动与验证 启动 docker 服务12$ sudo systemctl start docker$ sudo systemctl enable docker # 如果想添加到开机启动 验证安装是否成功(有client和service两部分表示docker安装启动都成功了) 123456789101112131415161718192021222324252627$ docker versionVersion: 19.03.1API version: 1.40Go version: go1.12.5Git commit: 74b1e89Built: Thu Jul 25 21:21:07 2019OS/Arch: linux/amd64Experimental: falseServer: Docker Engine - CommunityEngine:Version: 19.03.1API version: 1.40 (minimum version 1.12)Go version: go1.12.5Git commit: 74b1e89Built: Thu Jul 25 21:19:36 2019OS/Arch: linux/amd64Experimental: falsecontainerd:Version: 1.2.6GitCommit: 894b81a4b802e4eb2a91d1ce216b8817763c29fbrunc:Version: 1.0.0-rc8GitCommit: 425e105d5a03fabd737a126ad93d62a9eeede87fdocker-init:Version: 0.18.0GitCommit: fec3683 Docker 镜像加速地址 添加编辑daemon.json1234$ vim /etc/docker/daemon.json{ \"registry-mirrors\": [\"https://fy707np5.mirror.aliyuncs.com\"]} 重新加载并重启Docker 12$ systemctl daemon-reload$ systemctl restart docker Docker更新和卸载 更新 Docker CE1$ sudo yum update docker-ce 卸载 Docker CE1$ sudo yum remove docker-ce 删除本地文件1$ sudo rm -rf /var/lib/docker 注意 docker 的本地文件，包括镜像(images), 容器(containers), 存储卷(volumes)等，都需要手工删除。默认目录存储在 /var/lib/docker。 安装 docker-composeCURL安装出错按照官方文档，使用curl方式安装docker-compose后，验证是否安装成功时出错 安装时使用的命令12curl -L https://github.com/docker/compose/releases/download/1.14.0-rc2/docker-compose-`uname -s`-`ur/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 如果启动时报如下错误,说明curl安装方式下载的包不完整。[1814] Cannot open self /usr/local/bin/docker-compose or archive /usr/local/bin/docker-compose.pkg 安装包手动下载 进入官网, 选择最新版手动下载。当前最新1.25.0-rc2的docker-compose-Linux-x86_64 然后将文件上传到/usr/local/bin/ 文件夹下，然后将其重命名为docker-compose，修改此文件的权限，增加可执行：1chmod +x /usr/local/bin/docker-compose 然后再运行 12345$ docker-compose versiondocker-compose version 1.25.0-rc2, build 661ac20edocker-py version: 4.0.1CPython version: 3.7.4OpenSSL version: OpenSSL 1.1.0k 28 May 2019 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linux","slug":"linux","permalink":"https://www.zeffon.cn/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://www.zeffon.cn/tags/docker/"}]},{"title":"免费https通配符证书申请与配置","date":"2019-09-09T08:41:21.000Z","path":"posts/8ba17978.html","text":"前言Certbot是EFF加密整个互联网的一部分。通过Web进行安全通信依赖于HTTPS，这需要使用数字证书，以便浏览器验证Web服务器的身份。 Let’s Encrypt 简介随着阿里免费的HTTPS过期后，不得不使用免费使用HTTPS。所以就需要从证书授权机构(以下简称CA) 处获取一个证书，Let’s Encrypt 就是一个 CA。我们可以从 Let’s Encrypt 获得网站域名的免费的证书。这篇文章也主要讲的是通过 Let’s Encrypt + Nginx 来让网站升级到HTTPS。 Certbot 简介Certbot 是Let’s Encrypt官方推荐的获取证书的客户端，可以帮我们获取免费的Let’s Encrypt 证书。Certbot是EFF加密整个互联网的一部分。通过Web进行安全通信依赖于HTTPS，这需要使用数字证书，以便浏览器验证Web服务器的身份。Certbot 是支持所有 Unix 内核的操作系统的。 申请与配置Certbot安装 使用 Git 下载 certbot12$ git clone https://github.com/certbot/certbot$ cd certbot certbot-auto 或者 letsencrypt-auto查看命令参数123$ ./certbot-auto --help或者$ ./letsencrypt-auto --help 1234obtain, install, and renew certificates:(default) run Obtain &amp; install a certificate in your current webservercertonly Obtain or renew a certificate, but do not install itrenew Renew all previously obtained certificates that are near 12345678expiry enhance Add security enhancements to your existing configuration -d DOMAINS Comma-separated list of domains to obtain a certificate for --apache Use the Apache plugin for authentication &amp; installation --standalone Run a standalone webserver for authentication --nginx Use the Nginx plugin for authentication &amp; installation --webroot Place files in a server's webroot folder for authentication --manual Obtain certificates interactively, or using shell script 这里只对几个重要的命令参数进行说明 run：获取并安装证书到当前的Web服务器 certonly：获取或续期证书，但是不安装 renew：在证书快过期时，续期之前获取的所有证书 -d DOMAINS：一个证书支持多个域名，用逗号分隔 –apache：使用 Apache 插件来认证和安装证书 –standalone：运行独立的 web server 来验证 –nginx：使用 Nginx 插件来认证和安装证书 –webroot：如果目标服务器已经有 web server 运行且不能关闭，可以通过往服务器的网站根目录放置文件的方式来验证 –manual：通过交互式方式，或 Shell 脚本手动获取证书 关于域名验证和证书的获取安装，上面提到了5种方式：–apache, –standalone, –nginx, –webroot 和 –manual，请根据实际情况选择其一。这里会讲常用Nginx安装方式。 获取证书1. 使用 certbot-auto 来获取证书但不安装 1$ ./certbot-auto --email zeffonwu@gmail.com -d \"*.thxycn.xin\" -d \"thxycn.xin\" --manual --preferred-challenges dns-01 certonly --server https://acme-v02.api.letsencrypt.org/directory 注意将上面的邮箱和域名替换成自己的。需要两个-d：第一是通配符域名配置，第二个是主域名配置 注意 执行此命令必须使用 root用户获得文件夹的权限 域名能访问并且有绑定的公网IP 必须在此域名绑定的服务器上运行 会使用80断端口，如果nginx监听80端口，把nginx先关掉 2. 需要在域名上新添加一条解析记录(由于设置两个域名，这里解析记录值也要弄两次)(主机：_acme-challenge 类型：TXT 记录值：L435P35DFHIBAOF34548QoqJHbD162748HUDF) 123456Please deploy a DNS TXT record under the name_acme-challenge.thxycn.xin with the following value:L435P35DFHIBAOF34548QoqJHbD162748HUDFBefore continuing, verify the record is deployed. 注意: 申请通配符证书是要经过DNS认证的，按照提示，前往域名后台添加对应的DNS TXT记录。添加之后，不要心急着按回车，先执行dig xxxx.xxx.com txt确认解析记录是否生效，生效之后再回去按回车确认 dig 命令安装： 12345$ yum install bind-utils$ dig _acme-challenge.thxycn.xin下文出现TXT的值则可以;; ANSWER SECTION: _acme-challenge.thxycn.xin. 600 IN TXT \"Refivf35ferdfaypw7ZvfnmkbHDSD8433IGA\" 3. 获取证书出现如下的 NOTES,说明证书创建成功了 123456789IMPORTANT NOTES:- Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/thxycn.xin/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/thxycn.xin/privkey.pem Your cert will expire on 2019-11-30. To obtain a new or tweaked version of this certificate in the future, simply run letsencrypt-auto again. To non-interactively renew *all* of your certificates, run \"letsencrypt-auto renew\" 4. 查看证书(证书默认保存在/etc/letsencrypt/live/thxycn.xin) 1README cert.pem chain.pem fullchain.pem privkey.pem 而Nginx配置证书我们需要用到的证书是 fullchain.pem 和 privkey.pem。 Nginx证书配置1. 配置conf文件（注意更换自己的证书） 12345678910111213141516171819202122232425262728server { listen 443; server_name thxycn.xin; ssl on; ssl_certificate /etc/letsencrypt/live/thxycn.xin/fullchain.pem; # 替换自己的证书 ssl_certificate_key /etc/letsencrypt/live/thxycn.xin/privkey.pem; # 替换自己的证书 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; }}server { listen 80; server_name thxycn.xin; rewrite ^/(.*) https://$server_name$request_uri? permanent;} 2. 验证是否配置成功使用 https://thxycn.xin/index.html 能访问到Nginx的欢迎页面，则配置成功。 自动更新SSL证书Let’s Encrypt提供的证书只有90天的有效期，所以我们需要写一个脚本在过期前定时重新获取证书。并且证书获取是要频次限制的–每7天5次。(limit ~5 per 7 days)。1. 使用 certbot renew 自动更新证书 123$ certbot-auto renew --manual # 需要进入/usr/local/certbot目录或者可以使用强制更新$ certbot-auto --force-renew 但是却报错了。原因: 重新更新证书需要启动443端口，而这个端口被nginx占用着解决方法: 其实很简单，就是在执行certbot renew --dry-run命令前，把Nginx停止 systemctl stop nginx, 执行成功后就把Nginx启动 systemctl start nginx。所以需要用到 --pre-hook（这个参数表示执行更新操作之前要做的事情）,--post-hook(这个参数表示执行更新操作完成后要做的事情) 1. 定时设置(每1个月，凌晨10分执行)新建 certbot-auto-renew-crontab.sh 文件 123$ mkdir crontab # 与usr同级下新建crontab目录$ vi certbot-auto-renew-crontab.sh10 0 * 1 * /usr/local/certbot/certbot-auto --force-renew --pre-hook \"systemctl stop nginx\" --post-hook \"systemctl start nginx\" # --force-renew 强制更新 2. 用 crontab 来启动这个定时任务 1$ crontab certbot-auto-renew-crontab.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"AVL树、红黑树和哈希表","date":"2019-09-08T04:00:00.000Z","path":"posts/f534b102.html","text":"AVL 树 AVL树对于任意一个节点，左子树和右子树的高度差不能为超过1。红黑树是一种自平衡二叉查找树。哈希表也称散列表。 平衡二叉树的高度和节点数量之间的关系也是O(log n)的。 AVL树节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。 AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的AVL旋转。 失去平衡后进行的规律可归纳为下列四种情况： 右旋转(RR)12345678对节点y进行向右旋转操作，返回旋转后新的根节点x T1&lt; z &lt; T2 &lt; x &lt; T3 &lt; y &lt; T4 y x x.right = y / \\ / \\ y.left = T3 x T4 向右旋转 (y) z y / \\ - - - - - - - -&gt; / \\ / \\ z T3 T1 T2 T3 T4 / \\T1 T2 左旋转(LL)12345678对节点y进行向左旋转操作，返回旋转后新的根节点x T4 &lt; y &lt; T3 &lt; x &lt; T1 &lt; z &lt; T2 y x x.left = y / \\ / \\ y.right = T3T1 x 向左旋转 (y) y z / \\ - - - - - - - -&gt; / \\ / \\ T2 z T1 T2 T3 T4 / \\ T3 T4 LR12345678首先对x进行左旋转，转化为了LL的情况 y y / \\ / \\ x T4 向左旋转 (x) z T4 / \\ - - - - - - - -&gt; / \\ T1 z x T3 / \\ / \\ T2 T3 T1 T2 RL12345678首先对x进行右旋转，转化为了RR的情况 y y / \\ / \\T1 x 向右旋转 (x) T1 z / \\ - - - - - - - -&gt; / \\ z T4 T2 x / \\ / \\ T2 T3 T3 T4 Red black tree 红黑树红黑树等价于2-3树。红黑树是每个节点都带有颜色属性的二叉查找树 红黑树性质 : 每个节点是红色或者黑色。 根节点是黑色。 所有叶子都是黑色。 如果一个节点是红色的，那么它的孩子节点都是黑色的 从任意一个节点到叶子节点，经过的黑色节点是一样的。 性能总结 对于完全随机的数据，普通的二分搜索树很好用。缺点：极端情况退化成链表（或者高度不平衡） 对于查询较多的使用情况，AVL树很好用 红黑树牺牲了平衡性（2logn的高度），但它的统计性能更优（综合增删改查所有操作） 红黑树是保持黑平衡的二叉树。严格意义上不是平衡二叉树，最大高度: 2log n，时间复杂度: O(log n)。 红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。 扩展 java.util中的TreeMap和TreeSet基于红黑树实现的 红黑树是一种统计性能优秀的树结构，另一种是Splay Tree(伸展树)。它的局部性原理：刚被访问的内容下次高概率被再次访问。 Hash Table 哈希表哈希表概念哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。 哈希函数设计 哈希表充分表现了算法设计领域的经典思想：空间换时间 键通过函数函数得到的索引分布越均匀越好 处理冲突 链地址法：将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。 开放定址法 : 线性探测: 逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。 平方探测: 线性探测，相当于发生冲突时探测间隔 d =i^2 个单元的位置是否为空，如果为空，将地址存放进去。 二次探查: 一次散列产生哈希地址冲突，为了解决冲突，采用另外的散列函数或者对冲突结果进行处理的方法。 参考文献 维基百科-AVL树 维基百科-红黑树 维基百科-哈希表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线段树、字典树和并查集","date":"2019-09-07T04:00:00.000Z","path":"posts/2273a785.html","text":"Segment Tree 线段树 线段树也称区间树。字典树是多叉树，也称为前缀树。并查集是一种树型的数据结构。 线段树就是对于一棵二叉树，每一个节点其实存储的是每一个线段或者是一个区间相应的信息。 线段树不是完全二叉树，线段树是平衡二叉树，堆也是平衡二叉树。 完全二叉树本身就是平衡二叉树。平衡二叉树概念: 对于整棵树来说，最大的深度和最小的深度他们之间的差最多只有可能为1。 经典的线段树问题：区间染色、区间查询。用数组来实现这两个问题的话，更新和查询都是O(n)，而线段树则是O(log n)。 区间有n个元素，用数组表示的话需要4n的空间来存储。1234567890层：1 1层：2 2层：4 对于满二叉树：3层：8 h层，一共有2^h-1节点(大约是2^h)... 最后一层(h-1层)，有2^(h-1)个节点h-1层：2^(h-1) 最后一层的节点数大致等于前面所有层节点之和 如果n=2^k(满二叉树) 只需要2n的空间 最坏的情况，如果n=2^k+1 需要4n的空间 Trie 字典树 字典树是一种有序树，用于保存关联数组，其中的键通常是字符串。 字典树与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 UnionFind 并查集 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。 对一组数据，主要支持两个动作 : Union(p, q)：将两个子集合并成同一个集合。 isConnected(p, q)：查询给定两个元素他们是否属于同一个集合。它可以被用来确定两个元素是否属于同一子集。 参考文献 维基百科-字典树Trie 维基百科-并查集UnionFind document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"crontab的使用","date":"2019-09-06T04:00:00.000Z","path":"posts/973562d0.html","text":"介绍Linux crontab命令Linux 命令大全Linux crontab是用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。 crontab 定时任务通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 命令参数123456-u user：用来设定某个用户的crontab服务；file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。 命令格式 一个标准的 crontab 配置需要符合如下 :分 时 日 月 星期 要运行的命令12345678* * * * * command to be executed- - - - -| | | | || | | | +----- day of week (0 - 6) (Sunday=0)| | | +------- month (1 - 12)| | +--------- day of month (1 - 31)| +----------- hour (0 - 23)+------------- min (0 - 59) 一个 crontab 的配置文件，通过前五个域来表示时刻，时期，甚至是时间段。每一个域中，可以包含 * 或者逗号分割的数字，或者 - 连接的数字。1234* 号表示任意, 逗号分割表示时刻， separator- 短横线连接，表示时间段， range of values/ 表示间隔， 如果第一个域为 /2 ，则表示每隔两分钟， step value 而空格分割的六个域分别表示： 第 1 列分钟，取值范围 0～59 第 2 列小时 0～23（0 表示子夜） 第 3 列日 1～31 第 4 列月 1～12 第 5 列星期 0～7（0 和 7 表示星期天） 第 6 列要运行的命令 注意事项:重复格式 /2 表示没两分钟执行一次 或者 /10 表示每 10 分钟执行一次，这样的语法格式并不是被所有系统支持。具体某一天的指定，可以由第三项（month day）和第五项（weekday）指定，如果两项都被设定，那么 cron 都会执行。 安装&amp;使用crontab 安装 检查是否安装了crontab，如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。 12$ rpm -qa | grep crontabcrontabs-1.11-6.20121102git.el7.noarch # 已安装 crontabs安装包进行安装 1$ yum install -y cronie crontabs 检查crond服务是否安装及启动 1$ yum list crontabs &amp;&amp; which crontab &amp;&amp; crontab -l crontab 使用 systemctl 操作crontab 12345678910# 设置开机自启动$ systemctl enable crond # 开启$ systemctl start crond # 停止$ systemctl stop crond# 重启$ systemctl restart crond# 查看当前状态$ systemctl status crond 使用-l参数列出crontab文件: 12$ crontab -l10 0 * 1 * /usr/local/certbot/certbot-auto --force-renew --pre-hook \"systemctl stop nginx\" --post-hook \"systemctl start nginx\" 可以使用这种方法在 $HOME 目录中对 crontab 文件做一备份： 1$ crontab -l &gt; $HOME/mycron 这样，一旦不小心误删了 crontab 文件，可以用上面所讲述的方法迅速恢复。 添加crontab任务 1$ crontab -e 删除 crontab 文件 1crontab -r 注意 千万别乱运行crontab -r。它从Crontab目录 /var/spool/cron 中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 给某一个用户新建 crontab 任务 1sudo crontab -u test -e # 给test的用户设定定时任务，需要管理员权限 crontab配置文件 1$ vim /etc/crontab crontab日志 1$ tail -n 5 /var/log/cron // 查看最近五次日志 清理系统日志在/var/log路径，查看当前目录文件大小du -sh * 1* * 1 * * cat /dev/null &gt; /var/log/messages document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linux","slug":"linux","permalink":"https://www.zeffon.cn/tags/linux/"}]},{"title":"二叉堆和优先队列","date":"2019-09-05T04:00:00.000Z","path":"posts/95456b61.html","text":"前言二叉堆（binary heap）是一种特殊的堆，二叉堆是完全二叉树或者是近似完全二叉树。优先队列是计算机科学中的一类抽象数据类型。 正文Priority Queue 优先队列 普通队列是先进先出，后进后出；优先队列的出队入队只与优先级相关 优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。 常见的场景：操作系统中任务调度（动态选择优先级最高的任务执行） 基于不同底层实现时间复杂度比较 底层数据结构 插入时间复杂度 取出时间复杂度 无序数组 O(1) O(n) 有序数组 O(n) O(1) 堆 O(log n) O(log n) Binary Heap 二叉堆 二叉堆是一棵完全二叉树，不会退化为链表。（二叉树在特殊情况从小到大排序是会退化成链表） 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第 h 层所有的节点都连续集中在最左边，这就是完全二叉树。 二叉堆中的某个节点的值总是不大于其父节点的值。若根节点是最大值则成为最大堆,反之是最小堆。 二叉堆添加元素放在最后的叶子节点，再根据与其父节点的大小进行调整位置，直到满足所有的父子节点关系。 二叉堆删除根节点元素，将根节点与最后的叶子节点进行互换，删除最后的叶子节点，再将根节点与其子节点进行比较互换位置，直到满足所有的父子节点关系。 可以使用数组存储二叉堆。根节点为0，按层排序下去。则父节点与其子节点的关系如下: 123parent(i) = (i - 1) / 2left child(i) = 2 * i + 1right child(i) = 2 * i + 2 参考文献 维基百科-优先队列 维基百科-二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Markdown基础","date":"2019-09-04T04:00:00.000Z","path":"posts/b1c1e088.html","text":"基础语法Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 1.段落与换行 段落的前后必须是空行空行指的是行内什么都没有，或者只有空白符（空格或制表符，相邻两行文本，如果中间没有空行会显示在一行中（换行符被转换为空格） 如果需要在段落内加入换行（&lt;br&gt;）可以在前一行的末尾加入至少两个空格，然后换行写其它的文字 Markdown 中的多数区块都需要在两个空行之间。 2.标题1. Setext 形式 12345H1====H2---- = 和 - 的数量是没有限制的。通常的做法是使其和标题文本的长度相同，这样看起来比较舒服。或者可以像我一样，用四个 - 或 =。Setext 形式只支持 h1 和 h2 两种标题。 2. atx 形式① 可以用对称的 # 包括文本： 123####H4#########H5##### ② 也可以只在左边使用 #： 123####H4#####H5 ③ 成对的 # 左侧和只在左边使用的 # 左侧都不可以有任何空白，但其内侧可以使用空白。 123456789101112 ###左侧使用了空格####### 内侧使用了空格``` &gt;在这一点上，可能各种 Markdown 的实现会有不同的结果，不过仍然需要我们遵守语法规则。### 3.引用1\\. 引用内容 在段落或其他内容前使用 `&gt;` 符号，就可以将这段内容标记为 '引用' 的内容（`&lt;blockquote&gt;`）：```markdown&gt;引用内容 引用内容 2. 多行引用 12&gt;多行引用&gt;可以在每行前加 `&gt;` 多行引用可以在每行前加 &gt; 12&gt;如果仅在第一行使用 `&gt;`，后面相邻的行即使省略 `&gt;`，也会变成引用内容 如果仅在第一行使用 &gt;，后面相邻的行即使省略 &gt;，也会变成引用内容 1234&gt;如果引用内容需要换行， &gt;可以在行尾添加两个空格&gt;&gt;或者在引用内容中加一个空行 如果引用内容需要换行，可以在行尾添加两个空格 或者在引用内容中加一个空行 3. 嵌套引用 12&gt;也可以在引用中&gt;&gt;使用嵌套的引用 也可以在引用中 使用嵌套的引用 4. 其他 Markdown 1&gt;在引用中可以使用使用其他任何 *Markdown* 语法 在引用中可以使用使用其他任何 Markdown 语法 4.列表1. 无序列表 123* 可以使用 `*` 作为标记+ 也可以使用 `+`- 或者 `-` 可以使用 * 作为标记 也可以使用 + 或者 - 2. 有序列表 1231. 有序列表以数字和 `.` 开始； 3. 数字的序列并不会影响生成的列表序列； 4. 但仍然推荐按照自然顺序（1.2.3...）编写。 有序列表以数字和 . 开始； 数字的序列并不会影响生成的列表序列； 但仍然推荐按照自然顺序（1.2.3…）编写。 3. 嵌套的列表 1234561. 第一层+ 1-1+ 1-22. 无序列表和有序列表可以随意相互嵌套1. 2-12. 2-2 第一层 1-1 1-2 无序列表和有序列表可以随意相互嵌套 2-1 2-2 4. 语法和用法 无序列表项的开始是：符号 空格； 有序列表项的开始是：数字 . 空格； 空格至少为一个，多个空格将被解析为一个； 如果仅需要在行前显示数字和 .： 15\\. 可以使用：数字\\. 来取消显示为列表 5. 可以使用：数字\\. 来取消显示为列表 \\* 的语法专门用来显示 Markdown 语法中使用的特殊字符，参考字符转义 5.代码1. 代码块 - 可以使用缩进来插入代码块: &lt;html&gt; // Tab开头 &lt;title&gt;Markdown&lt;/title&gt; &lt;/html&gt; // 四个空格开头 代码块前后需要有至少一个空行，且每行代码前需要有至少一个 Tab 或四个空格；2. 行内代码也可以通过 ``，插入行内代码（` 是 Tab 键上边、数字 1 键左侧的那个按键）：例如 &lt;title&gt;Markdown&lt;/title&gt; 3. 转换规则代码块中的文本（包括 Markdown 语法）都会显示为原始内容，而特殊字符会被转换为 HTML 字符实体。 6.分隔线1. 可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（&lt;hr&gt;）： 123***------___ 2. 多个字符之间可以有空格（空白符），但不能有其他字符： 12* * *- - - 7.超链接1. 行内式 格式为 [link text](URL 'title text')。 ① 普通链接： 1[Google](http://www.google.com/) Google ② 指向本地文件的链接： 1[icon.png](./images/icon.png) icon.png ③ 包含 ‘title’ 的链接: 1[Google](http://www.google.com/ \"Google\") Google title 使用 ‘ 或 “ 都是可以的。 2. 参考式 参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。 ① 首先，定义链接： 1[Google][link] Google 第二个方括号内为链接独有的 识别符*，可以是字母、数字、空白或标点符号。识别符是 *不区分大小写 的； ② 然后定义链接内容： 1[link]: http://www.google.com/ \"Google\" 其格式为：[识别符]: URL 'title'。 其中，URL可以使用 &lt;&gt; 包括起来，title 可以使用 “”、’’、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写； 链接内容的定义可以放在同一个文件的 任意位置； ③ 也可以省略 识别符，使用链接文本作为 识别符： 12[Google][][Google]: http://www.google.com/ \"Google\" [Google][][Google]: http://www.google.com/ “Google” 参考式相对于行内式有一个明显的优点，就是可以在多个不同的位置引用同一个 URL。 3. 自动链接 使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接： 123&lt;http://www.google.com/&gt;&lt;123@email.com&gt; http://www.google.com/ 123@email.com 该方式适合行内较短的链接，会使用 URL 作为链接文字。邮箱地址会自动编码，以逃避抓取机器人。 8.图片插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 !。也分为行内式和参考式两种。 1. 行内式 1![GitHub](https://avatars3.githubusercontent.com/u/33784785?s=100&amp;v=3 \"GitHub,Social Coding\") GitHub,Social 方括号中的部分是图片的替代文本，括号中的 ‘title’ 部分和链接一样，是可选的。 2. 参考式 123![GitHub][github][github]: https://avatars3.githubusercontent.com/u/33784785?s=100&amp;v=3 \"GitHub,Social Coding\" 3. 指定图片的显示大小 Markdown 不支持指定图片的显示大小，不过可以通过直接插入&lt;img /&gt;标签来指定相关属性： 1&lt;img src=\"https://avatars3.githubusercontent.com/u/33784785?s=100&amp;v=3\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"50\" height=\"50\" /&gt; 9.强调1. 使用 * * 或 _ _ 包括的文本会被转换为 &lt;em&gt;&lt;/em&gt; ，通常表现为斜体： 1这是用来 *演示* 的 _文本_ 这是用来 演示 的 文本 2. 使用 ** ** 或 __ __ 包括的文本会被转换为 &lt;strong&gt;&lt;/strong&gt;，通常表现为加粗： 1这是用来 **演示** 的 __文本__ 这是用来 演示 的 文本 3. 用来包括文本的 * 或 _ 内侧不能有空白，否则 * 和 _ 将不会被转换（不同的实现会有不同的表现）： 1这是用来 * 演示* 的 _文本 _ 这是用来 * 演示* 的 _文本 _ 4. 如果需要在文本中显示成对的 * 或 _，可以在符号前加入 \\ 即可： 1这是用来 \\*演示\\* 的 \\_文本\\_ 这是用来 *演示* 的 _文本_ 5. *、**、_ 和 __ 都必须 成对使用 。 10.字符转义Markdown 标准 本身所包含的功能有限，所以产生了许多第三方的扩展语法，如 GitHub Flavored Markdown。这里只介绍众多扩展语法中的一部分内容，它们在不同平台或工具的支持程度不同，请参考具体平台或工具的文档和说明来使用。 删除线 代码块和语法高亮 表格 Task List CommonMarkCommonMark 试图将碎片化的 Markdown 实现和扩展进行标准化，提供统一的 规范 及不同语言的 实现 。 扩展语法1.删除线1这就是 ~~删除线~~ 这就是 删除线 2.代码块和语法高亮1. 代码块与原来使用缩进来添加代码块的语法不同，这里使用 ``` ``` 来包含多行代码： 1&lt;p&gt;code here&lt;/p&gt; 三个 ``` 要独占一行。 2. 代码高亮 在上面的代码块语法基础上，在第一组 ``` 之后添加代码的语言，如 ‘javascript’ 或 ‘js’，即可将代码标记为 JavaScript： 123window.addEventListener('load', function() { console.log('window loaded');}); 3.表格1. 单元格和表头 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行： 1234name | age---- | ---Zhangsan | 13Lisi | 14 name age Zhangsan 13 Lisi 14 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界： 1234| name | age || ---------- | --- || zhangsan | 13 || Listsi | 14 | name age zhangsan 13 Listsi 14 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 2. 对齐 在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： :--- 代表左对齐 :--: 代表居中对齐 ---: 代表右对齐 1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。 3. 插入其他内容 表格中可以插入其他 Markdown 中的行内标记： 1234| project | blog || ------------ | ------------------------------- || _ZeffonWu_ | [ZeffonWu](https://github.com/ZeffonWu) || __Blog__ | [Blog](https://github.com/ZeffonWu/ZeffonWu.github.io) | project blog ZeffonWu ZeffonWu Blog Blog 4.Task List123456- [ ] Eat- [x] Code - [x] HTML - [x] CSS - [x] JavaScript- [ ] Sleep Eat Code HTML CSS JavaScript Sleep 格式转换1.HTML1. MdCharm 选择 ‘File’, ‘Export to…’，勾选 ‘HTML’, 点击 ‘Browser…’ 选择导出目录并输入导出的文件名，点击 ‘OK’，即可将当前的 Markdown 文档转换为 HTML 文档。 如果不满意 HTML 文档的样式，可以在设置中自定义 CSS。 2. Pandoc 参考 Installing 安装 Pandoc。 打开命令行，进入文档所在目录： 1cd /path/to/file/ 执行下面的命令，将 Markdown 转换为 HTML： 1pandoc -o hello.html hello.md 默认的转换，只是将 Markdown 内容转换为 HTML 标签，所以只能看到浏览器的默认样式。 可以执行下面的命令，为导出的 HTML 添加自定义样式： 1pandoc -o hello.html -c style.css hello.md style.css 仍然是以 &lt;link&gt; 的方式关联到 HTML 文档中的，所以在发布的时候需要将 CSS 一同发布出去。 2.PDF1. MdCharm 与导出 HTML 文档类似，选择 ‘File’, ‘Export to…’，勾选 ‘PDF’, 点击 ‘Browser…’ 选择导出目录并输入导出的文件名，点击 ‘OK’，即可将当前的 Markdown 文档转换为 PDF 文档。 如果不满意 PDF 文档的样式，可以在设置中自定义 CSS。 1. Pandoc 使用 Pandoc 导出 PDF 文档，需要先安装某个 LaTeX 引擎（参考 Creating a PDF）。然后执行命令： 1pandoc -o hello.pdf hello.md 当然，也可以通过 -c style.css 来指定样式文件。 1. Chrome 在将 Markdown 转换为 HTML 文档 之后，可以通过 Chrome 浏览器 打开它。选择 ‘打印’（Ctrl+P），然后更改 ‘目标打印机’ 为 ‘另存为 PDF’，再进行一些设置后，即可保存为 PDF 文档。 3.Word1. 复制粘贴在导出为 HTML 文档之后，可以（在浏览器中）手动复制 HTML 页面的内容，然后粘贴到 Word 文档中，保存即可。 1. Pandoc执行下面的命令，即可将 Markdown 文档转换为 Word 文档： 1pandoc -o hello.docx hello.md 参考文献Github-LearnShare-Learning-Markdown document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"集合和映射","date":"2019-09-03T04:00:00.000Z","path":"posts/4fd121ef.html","text":"前言集合是承载元素的容器。映射（map）数据结构就是为此而设计的。映射用来存放键/值对。 正文Set 集合 集合的特点是：元素不重复，无下标。 集合的典型应用：客户统计、词汇量统计。 二分搜索树是非常好的实现集合的底层数据结构。 二分搜索树实现的集合时间复杂度平均为O(log n),链表实现的集合时间复杂度为O(n)。 多重集合中的元素可以重复 集合分类 集合分类 集合类型特性 底层数据结构的实现 有序集合 元素具有顺序性 基于搜索树的实现 无序集合 元素没有顺序性 基于哈希表的实现 集合的时间复杂度 (h表示树的高度) 操作 链表实现的集合 二分搜索树实现的集合 二分搜索树平均 增 add O(n) O(h) O(log n) 查 contains O(n) O(h) O(log n) 删 remove O(n) O(h) O(log n) Map 映射 映射主要是一对一间的对应关系。存储(键，值)数据对的数据结构(Key, Value), 根据键(Key)，寻找值(Value)。在其他语言中有着其他名称，如Python的字典dict。 二分搜索树是非常好的实现映射的底层数据结构。 映射集合中的键可以重复 映射分类 映射分类 映射类型特性 底层数据结构的实现 有序映射 键具有顺序性 基于搜索树的实现 无序映射 键没有顺序性 基于哈希表的实现 映射的时间复杂度 (h表示树的高度) 操作 链表实现的映射 二分搜索树实现的映射 二分搜索树平均 二分搜索树最差 增 add O(n) O(h) O(log n) O(n) 查 contains O(n) O(h) O(log n) O(n) 改 set O(n) O(h) O(log n) O(n) 查 get O(n) O(h) O(log n) O(n) 查 contains O(n) O(h) O(log n) O(n) Set集合与Map映射间的关系 其实集合与映射两者很大程度是相同的。如果将映射的值Value统一设置NULL，在这样看来映射也可以包装成集合。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Systemctl的使用","date":"2019-09-02T04:00:00.000Z","path":"posts/58aae0db.html","text":"前言Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。该篇学习于阮老师的Systemd 入门教程：命令篇和余泽楠的CentOS 7 Systemd 入门 Systemd 概述Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。 123$ systemctl --versionsystemd 219+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN Systemd 优缺点Systemd 的优点是功能强大，使用方便，而缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反keep simple, keep stupid的Unix 哲学。 使用Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 systemctl 命令systemctl 是 Systemd 的主命令，用于管理系统。 1234567891011121314151617181920# 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue 服务的管理1234567891011121314151617181920212223242526# 启动服务$ systemctl start &lt;服务项名称&gt;# 停止服务$ systemctl stop &lt;服务项名称&gt;# 重启服务$ systemctl restart &lt;服务项名称&gt;# 重新读取配置文件(如果该服务不能重启，但又必须使用新的配置，这条命令会很有用)$ systemctl reload &lt;服务项名称&gt;# 使服务开机自启动$ systemctl enable &lt;服务项名称&gt;# 使服务不要开机自启动$ systemctl disable &lt;服务项名称&gt;# 禁用服务(这可以防止服务被其他服务间接启动，也无法通过 start 或 restart 命令来启动服务)$ systemctl mask &lt;服务项名称&gt;# 启用服务(仅针对于已禁用的服务)$ systemctl unmask &lt;服务项名称&gt;# 重新读取所有服务项(修改、添加、删除服务项之后需要执行以下命令)$ systemctl daemon-reload UnitSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。 Unit 一共分成12种。 123456789101112Service unit：系统服务Target unit：多个 Unit 构成的一个组Device Unit：硬件设备Mount Unit：文件系统的挂载点Automount Unit：自动挂载点Path Unit：文件或路径Scope Unit：不是由 Systemd 启动的外部进程Slice Unit：进程组Snapshot Unit：Systemd 快照，可以切回某个快照Socket Unit：进程间通信的 socketSwap Unit：swap 文件Timer Unit：定时器 systemctl list-units命令可以查看当前系统的所有 Unit 1234567891011121314# 列出正在运行的 Unit$ systemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的$ systemctl list-units --all# 列出所有没有运行的 Unit$ systemctl list-units --all --state=inactive# 列出所有加载失败的 Unit$ systemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unit$ systemctl list-units --type=service 除了 status 命令，systemctl 还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。 12345678# 显示某个 Unit 是否正在运行$ systemctl is-active application.service# 显示某个 Unit 是否处于启动失败状态$ systemctl is-failed application.service# 显示某个 Unit 服务是否建立了启动链接$ systemctl is-enabled application.service 参考文献 Systemd 入门教程：命令篇 CentOS 7 Systemd 入门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linux","slug":"linux","permalink":"https://www.zeffon.cn/tags/linux/"}]},{"title":"flask项目在centos7部署流程","date":"2019-09-01T04:00:00.000Z","path":"posts/b68abf6b.html","text":"前言Flask 是一个web框架，而非web server，直接用Flask拉起的web服务仅限于开发环境使用，生产环境不够稳定，也无法承受大量请求的并发。基于Flask开发API项目是，部署时用uwsgi和Nginx，是一个很好的选择。 环境搭建Python3环境由于CentOS7原本就安装了Python2，而且这个Python2不能被删除，因为有很多系统命令，比如yum都要用到。所以我们要额外安装Python3，而且系统一般允许多个版本的python同时存在 我们先来查看python安装位置，一般是位于/usr/bin/python目录下。 12$ which python&gt;&gt; /usr/bin/python 安装Python3的方法 安装依赖包（切记安装）12$ yum -y groupinstall \"Development tools\"$ yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 下载Python3安装包大家可根据自己需求下载不同版本的Python3，我下载的是Python3.6.21$ wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 新建python3存放目录1$ mkdir /usr/local/python3 安装Python3解压压缩包，进入解压目录，指定安装目录，安装Python3。1234$ tar -xvJf Python-3.6.2.tar.xz$ cd Python-3.6.2$ ./configure --prefix=/usr/local/python3$ make &amp;&amp; make install 安装Python3时，会自动安装pip。假如没有，需要自己手动安装。1$ yum -y install python-pip 创建软链接12$ ln -s /usr/local/python3/bin/python3 /usr/bin/python3$ ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 安装完成，输入python3测试1234$ python3Python 3.6.2 (default, Mar 3 2019, 17:47:45)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information. pipenv创建虚拟环境pipenv是一个可以在同一计算机中隔离多个python版本的工具。有时，两个不同的项目可能需要不同版本的python，如 python2.7 / python3.6 ，但是如果都装到一起，经常会导致问题。pipenv能够用于创建独立的Python虚拟环境，多个Python相互独立，互不影响。pipenv这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过pipenv来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。 使用pip安装包前，先更新pip。 1$ pip3 install --upgrade pip 安装pipenv 1$ pip3 install pipenv 在项目目录进行虚拟环境搭建项目上传到服务器（推荐使用git的方式）进入项目目录，创建该项目的虚拟环境 1$ pipenv install # 需要进入项目的根目录 注意 如果报：Pipenv: Command Not Found 的错误用 $sudo pip install pipenv 重新安装pipenv 安装uwsig用pip安装 uwsgi库 1$ pip install uwsgi 激活虚拟环境并在项目下新建一个uwsgi.ini配置文件 123$ pipenv shell # 激活虚拟环境$ touch uwsgi.ini # 新建文件$ vi uwsgi.ini # 写入内容 123456789101112[uwsgi]chdir = /home/flask/lesson # manage.py文件所在目录callable = app # 为你的项目实例命名，flask项目需要这一句 wsgi-file= lesson.py # flask文件名 运行文件processes = 4 # 进程数threads = 2 # 线程数master = true # 开启一个master进程监控项目运行socket = 127.0.0.1:5000 # uwsgi的端口。要与项目运行的端口一致# daemonize = /home/flask/lesson/logs/lesson.logdaemonize = /tmp/flask/lesson.log # 日志输出目录touch-logreopen = /tmp/flask/.touchforlogrotate # 该文件变动时重新指定新的输出流到daemonizepidfile = uwsgi.pid 启动项目 123$ pipenv shell # 进入项目虚拟环境$ uwsgi uwsgi.ini # 启动命令（在lesson目录下）$ ps -ef | grep uwsgi # 查看进程是否启动成功 打开页面地址 服务器ip:5000 ，看看没有显示 Nginx配置Nginx下载Nginx 不在默认的 yum 源中，可以使用 epel 或者官网的 yum 源，本例使用官网的 yum 源。 添加nginx的yum源 1$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装完 yum 源之后，可以查看一下。 123456789101112$ sudo yum repolistLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.comrepo id repo name statusbase/7/x86_64 CentOS-7 - Base 9,911extras/7/x86_64 CentOS-7 - Extras 368nginx/x86_64 nginx repo 108updates/7/x86_64 CentOS-7 - Updates 1,041repolist: 11,428 可以发现 nginx repo 已经安装到本机了。 yum 安装 Nginx 1$ sudo yum install nginx 配置 Nginx 服务 1234$ sudo systemctl enable nginx # 设置开机启动(两次)$ sudo systemctl start nginx # 启动服务$ sudo systemctl stop nginx # 停止服务$ sudo systemctl reload nginx # 重新加载 nginx部署项目 进入nginx目录 1$ cd /etc/nginx 在conf.d中创建lesson.conf 12$ cd conf.d/$ vi lesson.conf 123456789101112131415161718192021222324252627282930server {&nbsp;&nbsp;&nbsp;&nbsp;# listen 80;&nbsp;&nbsp;&nbsp;&nbsp;listen 443;&nbsp;&nbsp;&nbsp;&nbsp;ssl on;&nbsp;&nbsp;&nbsp;&nbsp;server_name thxycn.xin;&nbsp;&nbsp;&nbsp;&nbsp;# 证书.pem的存放地址&nbsp;&nbsp;&nbsp;&nbsp;ssl_certificate /etc/nginx/cert/a.pem;&nbsp;&nbsp;&nbsp;&nbsp;# 证书.key的存放地址&nbsp;&nbsp;&nbsp;&nbsp;ssl_certificate_key /etc/nginx/cert/a.key;&nbsp;&nbsp;&nbsp;&nbsp;ssl_session_timeout 5m;&nbsp;&nbsp;&nbsp;&nbsp;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;&nbsp;&nbsp;&nbsp;&nbsp;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;&nbsp;&nbsp;&nbsp;&nbsp;ssl_prefer_server_ciphers on;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 项目根目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root /home/flask/lesson;&nbsp; # charset koi8-r;&nbsp;&nbsp;&nbsp;&nbsp;# access_log /var/log/nginx/lesson.log main; location / {&nbsp;&nbsp;&nbsp; include uwsgi_params;&nbsp;&nbsp;&nbsp;&nbsp; uwsgi_pass 127.0.0.1:5000; root /usr/share/nginx/html; index index.html index.htm; }}server {&nbsp;&nbsp;&nbsp;&nbsp;listen 80;&nbsp;&nbsp;&nbsp;&nbsp;server_name thxycn.xin;&nbsp;&nbsp;&nbsp;&nbsp;rewrite ^/(.*) https://$server_name$request_uri? permanent;} 重启Nginx 1$ sudo systemctl start nginx # 启动服务 日志切割uwsgi日志按天切割 指定touch-logreope文件在[uwsgi.ini]文件中 12daemonize = /tmp/flask/lesson.log # 日志输出目录touch-logreopen = /tmp/flask/.touchforlogrotate # 该文件变动时重新指定新的输出流到daemonize 这里把uwsgi的日志放在了/tmp/flask/下，这里有个trick，既touch-logreopen参数监控的文件就是后面要定时执行的shell脚本本身。可以精简一个空白文件。 创建一个自动sh脚本touchforlogrotate.sh放在日志目录/tmp/flask/下 1234567891011#!/bin/bash#获取当前目录DIR=`echo $(cd \"$(dirname \"$0\")\"; pwd)`sourcelogfile=\"${DIR}/lesson.log\"touchfile=\"${DIR}/.touchforlogrotate\"DATE=`date -d \"yesterday\" +\"%Y%m%d\"`#重命名后的文件destlogpath=\"${DIR}/lesson-${DATE}.log\"mv $sourcelogfile $destlogpath# 更新文件时间戳touch $touchfile crontab定时调用 10 0 * * * sh /tmp/flask/touchforlogrotate.sh 重启uwsgi，每天0时自动执行时，会把昨天的lesson-${DATE}.log对应到昨天日期的log文件。随着最后脚本touch了自己，今天又是全新的lesson-${DATE}.log。至此，就可以实现简单的日志按日期分片啦。 重启项目 123$ pipenv shell # 先进入项目根目录，再进入项目虚拟环境$ uwsgi uwsgi.ini # 启动命令（在lesson目录下）$ ps -ef | grep uwsgi # 查看进程是否启动成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"python","slug":"python","permalink":"https://www.zeffon.cn/tags/python/"},{"name":"nginx","slug":"nginx","permalink":"https://www.zeffon.cn/tags/nginx/"}]},{"title":"Java非线性结构 - 树","date":"2019-08-31T04:00:00.000Z","path":"posts/ee6021d7.html","text":"Tree 树二分搜索树（Binary Search Tree）是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。 二叉树 先介绍一下二叉树的性质 二叉树和链表一样，是动态数据结构。 二叉树具有天然递归结构 二叉树具有唯一根节点 二叉树每个节点最多有两个孩子 二叉树每个节点最多有一个父亲 没有孩子的节点称为叶子节点 二叉树不一定是满的。一个节点也是二叉树、空NULL也是二叉树 二分搜索树 二分搜索树是二叉树，不过二分搜索树需要满足如下要求: 二分搜索树的每个节点的值必须大于其左子树的所有节点的值 二分搜索树的每个节点的值必须小于其右子树的所有节点的值 每一棵子树也是二分搜索树 注意 二分搜索树存储的元素必须有可比较性。所以二分搜索树的值的类型需要可以进行比较的 二分搜索树的最小值和最大值 : 最小值 - 一直向左走(最左那个节点的值) 最大值 - 一直向右走(最右那个节点的值) 二分搜索树遍历 : 前序遍历 – 根节点 -&gt; 左节点 -&gt; 右节点 中序遍历 – 左节点 -&gt; 根节点 -&gt; 右节点 后序遍历 – 左节点 -&gt; 右节点 -&gt; 根节点 中序遍历将各个节点从小到大排序，后序遍历 – 释放内存采用栈实现前序遍历``非递归的写法，需要借助栈来标记节点 – 根节点先入栈，后出栈，再把其右、左孩子分别入栈，先出栈左孩子，然后入栈刚刚出栈节点的右、左孩子。若要出栈左节点无左右孩子，则出栈其父节点的右孩子(也就是其兄弟节点-右节点) 1234567891011121314// 二分搜索树的非递归前序遍历public void preOrderNR(){ Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()){ Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); }} 采用队列实现二分搜索树的层序遍历 – 先根节点入队，出队。把其左、右分别入队。先出对左孩子，再入对其刚刚出队节点的左右孩子。若左节点无左右孩子，则将其父节点的右孩子出队（也就是其兄弟节点-右节点）。 123456789101112131415// 二分搜索树的层序遍历public void levelOrder(){ if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) q.add(cur.left); if(cur.right != null) q.add(cur.right); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Linux搭建Git环境","date":"2019-08-30T04:00:00.000Z","path":"posts/23356a94.html","text":"前言 注 yum源仓库里的Git版本更新不及时，最新版本的Git是 1.8.3.1，但是官方最新版本已经到了2+。想要安装最新版本的的 Git，只能下载源码进行安装。 正文安装编译 查看yum源仓库git信息1$ yum info git 依赖库安装12$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel$ yum install gcc perl-ExtUtils-MakeMaker 卸载低版本的 Git1$ yum remove git 下载新版的 Git 源码包1234$ mkdir git # 我放的了 /usr/local/git 的目录下了，git是我自己mkdir的目录$ cd git$ wget https://github.com/git/git/archive/v2.9.2.tar.gz$ tar -xzvf v2.9.2.tar.gz 编译安装123$ cd git-2.9.2$ make prefix=/usr/local/git all$ make prefix=/usr/local/git install 添加到环境变量1234$ vim ~/.bash_profile # 如果没有vim，则安装vim工具 yum install vimexport PATH=\"/usr/local/git/bin:$PATH\"$ source ~/.bash_profile # 使配置立即生效$ git --version # 查看版本号 将git设置为默认路径(不然后面克隆时会报错)12$ ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-pack $ ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 服务配置 设置用户名和邮箱123$ git config --global user.name '用户名'$ git config --global user.email '邮箱地址'$ git config --list # 查看配置项 查看是否存在ssh keys123$ cd ~/.ssh$ lsauthorized_keys 没出现id_rsa 和 id_rsa.pub,则表示需要创建一个ssh keys 创建新的ssh keys 1$ ssh-keygen -t rsa -C \"邮箱\" 注意 如果三次直接回车(无密码push和pull)，也可以第二次和第三次输入密码（push和pull操作需要该密码验证） 测试一下连接 12$ ssh -T -v git@github.comYou've successfully authenticated 将~/.ssh中公钥id_rsa.pub的内容复制到各个平台(如github、gitee)的上公钥配置，实现ssh方式推送代码。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"git","slug":"git","permalink":"https://www.zeffon.cn/tags/git/"}]},{"title":"Java 基础线性结构","date":"2019-08-29T04:00:00.000Z","path":"posts/bd6be497.html","text":"前言线性结构是一个有序数据元素的集合。线性结构–数组、栈、队列、链表介绍 正文Array 数组 Array是一种线性结构，把数据码成一排进行存放，只能存放同一种类型多个元素。 Java Array属于静态数组 Array最大的优点：快速查询。例如：arr[1] Array最好应用与索引有语意的场景。 但并非所有有语意的索引都适应于Array。有些索引如（身份证号）长度太长了导致空间被浪费。 相关操作 添加操作 删除操作 修改操作 查找操作 复杂度 O(n) O(n) 已知索引O(1);未知索引O(n) 已知索引O(1);未知索引O(n) Stack 栈 Satck是一种先进后出的线性结构。 相比数组，栈对应的操作是数组的子集，只能从一端添加元素，也只能从这一端取出元素。这一端称为栈顶。 栈只能在栈顶操作数据: 在表尾进行插入和删除操作。 栈的使用场景: 我们经常使用的Undo(撤销操作)、程序调用的系统栈、括号匹配。 相关操作 入栈 出栈 查看栈顶 查看元素数量 判断是否为空 复杂度 O(1)均摊 O(1)均摊 O(1) O(1) O(1) Queue 队列 Queue是一种先进先出的线性结构。 相比数组，队列对应的操作是数组的子集。只能从一端队尾添加元素，只能从另一端队首取出元素。 队列的分类: 数组队列、循环队列 循环队列必定是要浪费掉一个空间不能存储数据的 循环队列 队列为空 队列满 (c表示队列的容量) 条件 front == tail (tail + 1) % c == front 相关操作 入队 出队 查看队首 查看元素数量 判断是否为空 复杂度 O(1)均摊 O(n) O(1) O(1) O(1) 注意 数组队列出列的时间复杂度为O(n),而循环队列均摊下来的复杂度为O(1). LinkedList 链表 最简单、真正的动态数据结构，数据存储在节点Node中。 节点: 把数据存储在一种单独数据结构中，一部分是数据，一部分是下一个节点，最后一个节点是NULL。 链表在添加和删除中，对数据操作的顺序很重要。在中间添加时，先将该元素的前一个节点找出来。 优点: 真正的动态数据，不需要像Array、Stack、Queue处理固定容量的问题 缺点: 不适合用于索引有语意的情况，因为它丧失了随机访问数据的能力 Recursion 递归 递归 : 本质上，将原来的问题，转化为更小的同一问题 递归基本原则: 所有递归问题基本上都可以分为以下两部分 求解最基本问题（这个最基本问题是不能自动求解的，需要编写逻辑求解的） 把原问题转化成更小的问题（核心部分） 举例 : 数组求和1234Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1]) &lt;- 更小的同一问题(少了一个元素)Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1]) &lt;- 更小的同一问题(少了一个元素) . . . . . .Sum(arr[n-1...n-1]) = arr[n-1] + Sum([]) &lt;- 最基本的问题 代码12345678910111213141516public static int sum(int[] arr){ return sum(arr, 0);}// 计算arr[l...n)这个区间内所有数字的和private static int sum(int[] arr, int l){ if(l == arr.length) return 0; &lt;- 最基本的问题 return arr[l] + sum(arr, l + 1); &lt;- 更小的同一问题}public static void main(String[] args) { int[] nums = {1, 2, 3, 4, 5, 6, 7, 8}; System.out.println(sum(nums));} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zeffon.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git的使用","date":"2019-08-28T04:00:00.000Z","path":"posts/c96ef7a4.html","text":"前言Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 正文基础命令 查看当前所连接的远程仓库 git remote -v 去除当前的远程仓库 git remote rm origin 添加远程仓库链接 git remote add origin git@gitee.com:Zeffon/test.git 克隆远程仓库 git clone git@gitee.com:Zeffon/test.git 暂存全部代码到缓冲区 git add . 提交到本地仓库 git commit -m \"&lt;commint info&gt;\" 推送到远程仓库 git psuh origin master 拉取远程仓库代码 git pull origin master Git分支 创建本地分支 dev $ git branch dev 切换本地分支 dev $ git checkout dev 相当于以上两条命令：创建 dev 分支并切换 $ git checkout -b dev 查看本地分支 $ git branch 删除本地分支 dev $ git branch -d dev 融合分支dev到主支master git merge --no-ff -m \"提交信息\" dev 推送分支 git push origin local_branch:remote_branch Git标签 在Git中打标签非常简单，首先，切换到需要打标签的分支上 12$ git branch$ git checkout master 然后，敲命令git tag &lt;name&gt;就可以打一个新标签 1$ git tag v1.0 可以用命令git tag查看所有标签 123$ git tagv0.9v1.0 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 推送标签到远程，使用命令git push origin &lt;tagname&gt; 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git[new tag] v1.0 -&gt; v1.0 一次性推送全部尚未推送到远程的本地标签 git push origin --tags 删除标签 git tag -d v1.0 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag 'v0.9' (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git[deleted] v0.9 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"git","slug":"git","permalink":"https://www.zeffon.cn/tags/git/"}]},{"title":"Jekyll环境的搭建","date":"2019-08-27T04:00:00.000Z","path":"posts/8e7ed75b.html","text":"前言Jekyll 是一个简单的，博客感知，静态站点生成器，与github的pages很相配。 正文安装ruby环境(mac自带 ruby -v)1$ brew install ruby 修改Jekyll版本 mac安装jekyll 需要ruby大于2.4（mac自带2.3.x）12$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"$ brew install ruby 添加到shell配置1$ export PATH=/usr/local/opt/ruby/bin:$PATH 查看路径和版本1234$ which ruby/usr/local/opt/ruby/bin/ruby$ ruby -vruby 2.6.3p62 (2019-04-16 revision 67580) [x86_64-darwin18] 安装rbenv管理ruby版本1234567/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" $ brew install rbenv$ rbenv init$ curl -fsSL https://github.com/rbenv/rbenv-installer/raw/master/bin/rbenv-doctor | bash$ rbenv install 2.6.3 $ rbenv global 2.6.3 $ ruby -v 配置加速 查看源列表1$ gem sources -l 将国外源移除，并添加国内源12$ gem sources --remove https://rubygems.org/$ gem sources --add https://gems.ruby-china.com/ 缓存国内源1$ gem sources -u 全局安装Jekyll和Jekyll bundler12$ sudo gem install bundler$ sudo gem install -n /usr/local/bin/ jekyll 博客创建与运行 新建blog博客1$ jekyll new blog 安装bundle(依赖)1$ sudo bundle install 启动项目1$ bundle exec jekyll server Now browse to http://localhost:4000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.zeffon.cn/tags/%E6%9D%82%E8%AE%B0/"}]}]